filter {

  if ([id] and [results] and [service][type]) {

    ruby {
      id => "ruby_filescan_remove_empty_values"
      path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
    }

    if (![event][provider]) {
      mutate {
        id => "filescan_event_provider_fallback"
        add_field => { "[event][provider]" => "filescan" }
      }
    }

    if (![event][dataset]) and ([results][strelka]) {
      mutate {
        id => "filescan_event_dataset_strelka"
        add_field => { "[event][dataset]" => "strelka" }
      }
    }

    # parse the "raw" record passed along as metadata as JSON into @metadata.raw
    if ([metadata][record]) { json {
      id => "filescan_parse_metadata_record"
      source => "[metadata][record]"
      target => "[entity][raw]"
    } } else if ([results][strelka][result][request][attributes][metadata][record]) { json {
      id => "filescan_parse_result_request_metadata_record"
      source => "[results][strelka][result][request][attributes][metadata][record]"
      target => "[entity][raw]"
    } } else if ([results][strelka][result][file][metadata][record]) {
      mutate { id => "mutate_filescan_rename_record_to_raw"
               rename => { "[results][strelka][result][file][metadata][record]" => "[entity][raw][file]" } }
    }

    # store metadata.raw.file._path as dataset, and then move metadata.raw.file to where the
    # originating log normally would be (e.g., service.type:zeek, metadata.raw.file._path:files => zeek.files)
    if ([entity][raw][file][_path]) {
      mutate {
        id => "mutate_filescan_save_raw_log_file_path"
        copy => { "[entity][raw][file][_path]" => "[@metadata][log_file_type]" }
        remove_field => [ "[entity][raw][file][_path]", "[entity][raw][file][_write_ts]" ]
      }
      ruby { id => "ruby_add_file_log_type_to_filescan_dataset"
             code => "event.set('[event][dataset]', [ event.get('[@metadata][log_file_type]'), event.get('[event][dataset]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
      mutate { id => "mutate_rename_raw_to_original_type"
               rename => { "[entity][raw][file]" => "[%{[service][type]}][%{[@metadata][log_file_type]}]" } }
    }
    # put netbox site in the right place for enrichment later
    if [entity][raw][netbox][site] {
      mutate {
        id => "mutate_filescan_add_entity_raw_netbox_site"
        copy => { "[entity][raw][netbox][site]" => "[@metadata][nbsiteid]" }
      }
    } else if [results][strelka][result][file][metadata][record][netbox][site] {
      mutate {
        id => "mutate_filescan_add_result_record_netbox_site"
        copy => { "[results][strelka][result][file][metadata][record][netbox][site]" => "[@metadata][nbsiteid]" }
      }
    }

    # store the originating host name as it's probably what people will want to search by. we'll actually do the replacement
    #   when we're finalizing the event, since we want the one that's currently stored in host.name so we can do reachback
    #   for the file.  99% of the time they'll be the same thing, but with K8s they might not be.
    if [entity][raw][host][name] {
      mutate {
        id => "mutate_filescan_add_entity_raw_host_name"
        copy => { "[entity][raw][host][name]" => "[@metadata][orighostname]" }
      }
    } else if [results][strelka][result][file][metadata][record][host][name] {
      mutate {
        id => "mutate_filescan_add_result_record_host_name"
        copy => { "[results][strelka][result][file][metadata][record][host][name]" => "[@metadata][orighostname]" }
      }
    }

  } else {
    drop { id => "drop_filescan_invalid_logs" }
  }

}
