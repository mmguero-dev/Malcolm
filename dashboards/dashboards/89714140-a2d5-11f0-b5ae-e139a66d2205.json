{
  "objects": [
    {
      "attributes": {
        "description": "Trees are Malcolm analytics designed to be utilized by analysts to assist in tracking lateral movement across a network.",
        "hits": 0,
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"highlightAll\":false,\"version\":true,\"query\":{\"query\":\"\",\"language\":\"kuery\"},\"filter\":[]}"
        },
        "optionsJSON": "{\"useMargins\":true}",
        "panelsJSON": "[{\"version\":\"3.2.0\",\"gridData\":{\"x\":0,\"y\":0,\"w\":8,\"h\":33,\"i\":\"1\"},\"panelIndex\":\"1\",\"embeddableConfig\":{},\"panelRefName\":\"panel_0\"},{\"version\":\"3.2.0\",\"gridData\":{\"x\":8,\"y\":0,\"w\":40,\"h\":42,\"i\":\"76ed91be-9cfa-4ab6-97ea-176dff62779a\"},\"panelIndex\":\"76ed91be-9cfa-4ab6-97ea-176dff62779a\",\"embeddableConfig\":{},\"panelRefName\":\"panel_1\"}]",
        "timeRestore": false,
        "title": "Trees",
        "version": 1
      },
      "id": "89714140-a2d5-11f0-b5ae-e139a66d2205",
      "migrationVersion": {
        "dashboard": "7.9.3"
      },
      "namespaces": [
        "default"
      ],
      "references": [
        {
          "id": "df9e399b-efa5-4e33-b0ac-a7668a8ac2b3",
          "name": "panel_0",
          "type": "visualization"
        },
        {
          "id": "ab8b2ef0-a2d3-11f0-b5ae-e139a66d2205",
          "name": "panel_1",
          "type": "visualization"
        }
      ],
      "type": "dashboard",
      "updated_at": "2025-10-06T17:36:51.496Z",
      "version": "WzEyNzEsMV0="
    },
    {
      "attributes": {
        "description": "",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":{\"query_string\":{\"query\":\"*\"}},\"language\":\"lucene\"},\"filter\":[]}"
        },
        "title": "Navigation",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"Navigation\",\"type\":\"markdown\",\"params\":{\"markdown\":\"MALCOLM_NAVIGATION_MARKDOWN_REPLACER\",\"type\":\"markdown\",\"fontSize\":10,\"openLinksInNewTab\":false},\"aggs\":[]}"
      },
      "id": "df9e399b-efa5-4e33-b0ac-a7668a8ac2b3",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-10-06T17:32:53.734Z",
      "version": "WzEyNTAsMV0="
    },
    {
      "attributes": {
        "description": "Trees are Malcolm analytics designed to be utilized by analysts to assist in tracking lateral movement across a network.",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":\"\",\"language\":\"kuery\"},\"filter\":[]}"
        },
        "title": "Trees",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"Trees\",\"type\":\"vega\",\"aggs\":[],\"params\":{\"spec\":\"  {\\n    /**\\n      Authors:\\n        Mackenzie Zappe (mackenzie.zappe@inl.gov)\\n        Shelby Hiens\\n        Nicholas Donovan\\n      References:\\n        https://vega.github.io/vega/docs/\\n        https://vega.github.io/vega/examples/tree-layout/\\n    **/\\n    ##  Set up Vega specification definitions\\n    ##  Pay attention to Vega additions after V5\\n    // ## todo stop on broadcasts\\n    \\\"$schema\\\": \\\"https://vega.github.io/schema/vega/v5.json\\\",\\n    // Make room for binds under the graph\\n    \\\"autosize\\\": {\\n      \\\"type\\\": \\\"fit-x\\\",\\n      \\\"contains\\\": \\\"padding\\\"\\n    },\\n    \\\"padding\\\": {\\n      \\\"left\\\": 5,\\n      \\\"top\\\": 5,\\n      \\\"right\\\": 5,\\n      \\\"bottom\\\": -100\\n    },\\n    ##  --------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 0: Config --------------------------------------------------------------------------------------------------------\\n    ##  Define Specification constants like multiple instruction positioning\\n    ##  - arguments set in Config WILL be overwritten if redefined later in specification\\n    \\\"config\\\": {\\n      \\\"signals\\\": [\\n        // Adjust font scale based on display size\\n        {\\n          \\\"name\\\": \\\"fontScale\\\",\\n          \\\"update\\\": \\\"clamp(min(width / 1920, height / 1080), 0.5, 1.3)\\\"\\n        },\\n        {\\n          \\\"name\\\": \\\"paddingScale\\\",\\n          \\\"update\\\": \\\"clamp(min(width / 1920, height / 1080), 0.5, 2)\\\"\\n        },\\n        {\\n          \\\"name\\\": \\\"labelFontSize\\\",\\n          \\\"init\\\": \\\"16 * fontScale\\\"\\n        },\\n        {\\n          \\\"name\\\": \\\"titleFontSize\\\",\\n          \\\"init\\\": \\\"20 * fontScale\\\"\\n        },\\n        // Warn if data truncated\\n        {\\n          \\\"name\\\": \\\"maxDataSize\\\",\\n          \\\"value\\\": 10000\\n        },\\n        {\\n          \\\"name\\\": \\\"dataMaxed\\\",\\n          \\\"update\\\": \\\"length(data('table')) >= maxDataSize\\\"\\n        },\\n        {\\n          \\\"name\\\": \\\"maxedWarning\\\", // Warning to display to user if number of documents being processed exceeds 10k per Vega limitation\\n          \\\"update\\\": \\\"dataMaxed ? warn('Maximum data response reached. Data may be truncated. Try adjusting timeframe.') : null\\\"\\n        },\\n        {\\n          \\\"name\\\": \\\"labelOffset\\\",\\n          \\\"value\\\": 15\\n        }\\n      ],\\n      \\\"axis\\\": {\\n        \\\"titleFontSize\\\": {\\n          \\\"signal\\\": \\\"titleFontSize\\\"\\n        },\\n        \\\"titlePadding\\\": {\\n          \\\"signal\\\": \\\"25 * paddingScale\\\"\\n        },\\n        \\\"labelFontSize\\\": {\\n          \\\"signal\\\": \\\"labelFontSize * .9\\\"\\n        },\\n        \\\"tickWidth\\\": 3\\n      },\\n      \\\"title\\\": {\\n        \\\"fontSize\\\": {\\n          \\\"signal\\\": \\\"titleFontSize * 1.2\\\"\\n        }\\n      },\\n      \\\"instruction\\\": {\\n        \\\"titleFontSize\\\": {\\n          \\\"signal\\\": \\\"titleFontSize * 0.9\\\"\\n        },\\n        \\\"labelFontSize\\\": {\\n          \\\"signal\\\": \\\"labelFontSize\\\"\\n        },\\n        \\\"padding\\\": {\\n          \\\"signal\\\": \\\"10 * paddingScale\\\"\\n        }\\n      },\\n      \\\"text\\\": {\\n        \\\"fontSize\\\": {\\n          \\\"signal\\\": \\\"labelFontSize * 0.9\\\"\\n        },\\n        \\\"baseline\\\": \\\"middle\\\"\\n      },\\n      \\\"rule\\\": {\\n        \\\"strokeWidth\\\": 0.2,\\n        \\\"stroke\\\": \\\"firebrick\\\"\\n      }\\n    },\\n    ##  ---------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 1: Signals --------------------------------------------------------------------------------------------------------\\n    ##  - Define dynamic variables (Signals) that can be updated at any point during the specification\\n    \\\"signals\\\": [\\n      //    logs into console run `VEGA_DEBUG.view.logLevel(3)` in console first\\n      //    {\\n      //      \\\"name\\\": \\\"logger\\\",\\n      //      \\\"on\\\": [\\n      //        {\\n      //          \\\"events\\\": {\\\"signal\\\":  \\\"clear\\\"},\\n      //          \\\"update\\\": \\\"info(clear)\\\"\\n      //        }\\n      //      ],\\n      //    },\\n      // Takes User Input to define the initial root \\n      {\\n        \\\"name\\\": \\\"userInputRoot\\\",\\n        \\\"init\\\": null,\\n        \\\"bind\\\": {\\n          \\\"input\\\": \\\"search\\\",\\n          \\\"placeholder\\\": \\\"  x.x.x.x \\\", // place holder to show syntax to user - spaces used to center placeholder in bind box \\n          \\\"name\\\": \\\"Root IP\\\",\\n          \\\"debounce\\\": 1200\\n        }\\n      },\\n      // Finds the index of the root src IP\\n      {\\n        \\\"name\\\": \\\"rootIndex\\\",\\n        \\\"update\\\": \\\"indexof(pluck(data('table'), 'src'), userInputRoot) \\\"\\n      },\\n\\n      // Pulls the src information based on the rootIndex and stores it as intitialRoot\\n      {\\n        \\\"name\\\": \\\"initialRoot\\\",\\n        \\\"update\\\": \\\"pluck(data('table'), 'src')[rootIndex]\\\",\\n      },\\n\\n      // pulls enrichment data for the intialRoot based on rootIndex\\n      {\\n        \\\"name\\\": \\\"initialRootData\\\",\\n        \\\"update\\\": \\\"pluck(data('table'), 'aggregated_objs')[rootIndex]\\\",\\n      },\\n\\n      {\\n        \\\"name\\\": \\\"treeDepth\\\",\\n        \\\"update\\\": \\\"data('completeTree') && data('completeTree').root ? data('completeTree').root.height : -1\\\"\\n      },\\n      // Allow the depth of the tree to be chosen\\n      {\\n        \\\"name\\\": \\\"n\\\",\\n        \\\"init\\\": 3,\\n        \\\"bind\\\": {\\n          \\\"input\\\": \\\"range\\\",\\n          \\\"min\\\": 1,\\n          \\\"max\\\": 15,\\n          \\\"step\\\": 1,\\n          \\\"name\\\": \\\"Tree Height\\\",\\n          \\\"debounce\\\": 300\\n        }\\n      },\\n      // time filter toggle \\n    {\\n      \\\"name\\\": \\\"timeFilter\\\",\\n      \\\"init\\\": \\\"'Off'\\\",\\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"radio\\\",\\n        \\\"options\\\": [\\\"On\\\", \\\"Off\\\"],\\n        \\\"name\\\": \\\"Time Filter\\\",\\n        \\\"debounce\\\": 300\\n      }\\n    },\\n    {\\n      \\\"name\\\": \\\"On\\\",\\n      \\\"init\\\": \\\"\\\",\\n      \\\"debounce\\\": 300\\n    },\\n    {\\n      \\\"name\\\": \\\"Off\\\",\\n      \\\"update\\\": \\\"\\\",\\n      \\\"debounce\\\": 300\\n    },\\n    // change scale for nodeColor \\n      {\\n        \\\"name\\\": \\\"nodeColor\\\",\\n        \\\"init\\\": \\\"'set1'\\\",\\n        \\\"bind\\\": {\\n          \\\"input\\\": \\\"select\\\",\\n          \\\"options\\\": [\\\"observable10\\\", \\\"dark2\\\", \\\"paired\\\", \\\"set1\\\"],\\n          \\\"name\\\": \\\"Node Color\\\",\\n          \\\"debounce\\\": 1200\\n        }\\n      },\\n      // Save n history as [previous, current]\\n      {\\n        \\\"name\\\": \\\"nHist\\\",\\n        \\\"value\\\": [\\n          3\\n        ],\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": {\\n              \\\"signal\\\": \\\"n\\\"\\n            },\\n            \\\"update\\\": \\\"slice(split(join(nHist)+','+n, ','), -2)\\\"\\n          }\\n        ]\\n      },\\n      // Save previous n\\n      {\\n        \\\"name\\\": \\\"nPrev\\\",\\n        \\\"update\\\": \\\"toNumber(nHist.length > 1 ? nHist[nHist.length-2] : nHist[0])\\\"\\n      },\\n      // When n shrinks we need to clear the graph and rebuild the tree\\n      {\\n        \\\"name\\\": \\\"clear\\\",\\n        \\\"init\\\": \\\"false\\\",\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": {\\n              \\\"signal\\\": \\\"n\\\"\\n            },\\n            \\\"update\\\": \\\"n <= nPrev\\\",\\n            \\\"force\\\": true\\n          },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"timeFilter\\\"\\n          },\\n          \\\"update\\\": \\\"timeFilter\\\",\\n          \\\"force\\\": true\\n        },\\n        ]\\n      },\\n      // A counter that triggers the BF iteration\\n      {\\n        \\\"name\\\": \\\"step\\\",\\n        \\\"value\\\": 0,\\n        \\\"on\\\": [\\n          {\\n            // check the `update` condition every 50 ms\\n            \\\"events\\\": {\\n              \\\"type\\\": \\\"timer\\\",\\n              \\\"throttle\\\": 50\\n            },\\n            \\\"update\\\": \\\"data('next') && length(data('next')) ? step + 1 : step\\\"\\n          }\\n        ]\\n      },\\n      // Signals for collapsing a clicked node\\n      {\\n        \\\"name\\\": \\\"clicked\\\",\\n        \\\"value\\\": null,\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": \\\"@node:click\\\",\\n            \\\"update\\\": \\\"{'id': datum.dst}\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n          {\\n            \\\"events\\\": \\\"@nodeLabel:click\\\",\\n            \\\"update\\\": \\\"{'id': datum.dst}\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          }\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"clearCollapsed\\\",\\n        \\\"value\\\": false,\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": \\\"dblclick[!event.item]\\\",\\n            \\\"update\\\": \\\"true\\\",\\n            \\\"force\\\": true\\n          }\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"count_num_connections\\\",\\n        //\\\"value\\\": 0,\\n        //\\\"init\\\": \\\"data(datum.proto)\\\"\\n      },\\n      //Return the index of the device_array where the ip matches the current node's dst field \\n      {\\n        \\\"name\\\": \\\"nodeEnrich\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"indexof(pluck(datum.device_array, 'ip'), datum.dst)\\\",\\n            \\\"force\\\": \\\"true\\\",\\n          },\\n          {\\n            \\\"events\\\": \\\"@node:mouseout\\\",\\n            \\\"update\\\": \\\"{}\\\",\\n            \\\"debounce\\\": 1000,\\n          },\\n        ]\\n      },\\n      //Get the data at nodeEnrich index from the device_array\\n      {\\n        \\\"name\\\": \\\"device_data\\\",\\n        \\\"value\\\": \\\"{'ip': null}\\\", //declare initial as null to avoid startup error \\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"datum.device_array[nodeEnrich]\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n          {\\n            \\\"events\\\": \\\"@node:mouseout\\\",\\n            \\\"update\\\": \\\"{}\\\",\\n            //\\\"debounce\\\": 1000,\\n          },\\n        ]\\n      },\\n      // Determine if netbox enrichment exists for a node and then pull the role value as a string \\n      {\\n        \\\"name\\\": \\\"netbox_role\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data.device && device_data.device.role ? device_data.device.role[0] : null\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n        ]\\n      },\\n      // Determine if netbox enrichment exists for a node and then pull the name value as a string \\n      {\\n        \\\"name\\\": \\\"netbox_name\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data.device && device_data.device.name ? device_data.device.name[0] : null\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n        \\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"device_mac\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data.mac ? device_data.mac[0] : null \\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n        \\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"device_oui\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data.oui ? device_data.oui : null\\\",\\n            \\\"force\\\": true,\\n          }\\n        ]\\n      }\\n      // Format the node hover data so tooltip is populated \\n      {\\n        \\\"name\\\": \\\"device_info\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"{'IP': device_data.ip, 'MAC': device_mac, 'OUI': device_oui, 'As': device_data.as, 'Netbox Name': netbox_name,  'Nexbox Role': netbox_role }\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n          {\\n            \\\"events\\\": \\\"@node:mouseout\\\",\\n            \\\"update\\\": \\\"{}\\\",\\n            //\\\"debounce\\\": 1000,\\n          },\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"color\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\":\\\"@node:mouseover\\\",\\n            \\\"update\\\":\\\"rgb(rgb(scale('color', datum.depth)).r * 0.7, rgb(scale('color', datum.depth)).g * 0.7, rgb(scale('color', datum.depth)).b * 0.7)\\\"\\n          }\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"tooltip2\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'conn_state')\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"tooltip3\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'protocolArr')\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"byte_data\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'bytesArr')\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"enrichmentSrc\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'src')\\\"},\\n          // {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"{'src': datum.source.src, 'dst': datum.source.dst}\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"enrichmentDst\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'dst')\\\"},\\n          // {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"{'src': datum.source.src, 'dst': datum.source.dst}\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"bytes_extent\\\",\\n        \\\"update\\\": \\\"{'min': pluck(data('bytesExtent'), 'byteMin')[0], 'max': pluck(data('bytesExtent'), 'byteMax')[0]}\\\"\\n      },\\n    {\\n      \\\"name\\\": \\\"time_extent\\\",\\n      \\\"update\\\": \\\"{'min': pluck(data('timeExtent'), 'timeMin'), 'max': pluck(data('timeExtent'), 'timeMax')}\\\"\\n    },\\n      {\\n        \\\"name\\\": \\\"connection_time\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"datum.target.date_obj\\\"},\\n          // {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"{'src': datum.source.src, 'dst': datum.source.dst}\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"legend_height\\\", \\\"value\\\": 28\\n      },\\n    ],\\n    ## --------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 2: DATA --------------------------------------------------------------------------------------------------------\\n    ##  Define datasets and data normalization to be worked with in schema\\n    \\\"data\\\": [\\n      {\\n        // 'Raw' data that is being pulled using opensearch dsl and aggregations capability\\n        // https://docs.opensearch.org/latest/query-dsl/\\n        // https://docs.opensearch.org/latest/aggregations/bucket/index/\\n\\n\\n        \\\"name\\\": \\\"table\\\",\\n        \\\"url\\\": {\\n          \\\"index\\\": \\\"MALCOLM_NETWORK_INDEX_PATTERN_REPLACER\\\",\\n          \\\"body\\\": {\\n            \\\"query\\\": {\\n              \\\"bool\\\": {\\n                \\\"must\\\": [\\n                  {\\n                    \\\"match\\\":{\\n                      \\\"event.provider\\\":\\\"zeek\\\",\\n                    },\\n                    \\\"match\\\":{\\n                      \\\"event.dataset\\\":\\\"conn\\\",\\n                    }\\n                  }\\n                  \\\"%dashboard_context-must_clause%\\\"\\n                ],\\n                \\\"must_not\\\": [\\n                  \\\"%dashboard_context-must_not_clause%\\\"\\n                ],\\n                \\\"filter\\\": [\\n                  \\\"%dashboard_context-filter_clause%\\\",\\n                  {\\n                    \\\"range\\\": {\\n                      \\\"MALCOLM_OTHER_INDEX_TIME_FIELD_REPLACER\\\": {\\n                        \\\"%timefilter%\\\": true\\n                      }\\n                    }\\n                  },\\n                  {\\n                    \\\"exists\\\": {\\n                      \\\"field\\\": \\\"event.id\\\"\\n                    }\\n                  },\\n                  {\\n                    \\\"exists\\\": {\\n                      \\\"field\\\": \\\"timestamp\\\"\\n                    }\\n                  },\\n\\n              ]\\n            }\\n          },\\n          // assign all relevant destination ips to each unique source\\n          \\\"aggs\\\": {\\n          ##  Define parameters for \\n            \\\"connections\\\": {\\n              \\\"composite\\\": {\\n                \\\"size\\\": 10000,\\n                \\\"sources\\\": [\\n                  {\\\"src\\\": { \\\"terms\\\": {\\\"field\\\": \\\"source.ip\\\"} } },\\n                  {\\\"dst\\\": {\\\"terms\\\": {\\\"field\\\": \\\"destination.ip\\\"}} },\\n                  // {\\\"protocol\\\": {\\\"terms\\\": {\\\"field\\\": \\\"protocol\\\"}} },\\n                  {\\\"conn_state\\\": {\\\"terms\\\": {\\\"field\\\": \\\"zeek.conn.conn_state\\\"}}}\\n                ]\\n              },\\n                \\\"aggs\\\": {\\n                  \\\"metadata\\\": {\\n                    \\\"top_hits\\\": {\\n                      \\\"size\\\": 1,\\n                      \\\"_source\\\": {\\n                        \\\"includes\\\": [\\n                          \\\"source\\\",\\n                          \\\"destination\\\",\\n                          \\\"protocol\\\",\\n                          \\\"totDataBytes\\\",\\n                          \\\"timestamp\\\",\\n                        ]\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n          \\\"size\\\": 0 \\n          // this applies to hits, not aggregations, faster and reduces data size\\n      },\\n      \\\"format\\\": {\\n        \\\"property\\\": \\\"aggregations.connections.buckets\\\"\\n      },\\n      \\\"transform\\\": [\\n        // surfaced aggregated objs, src and dst device, protocols, segment names, conn states in the metadata (prettification)\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.metadata.hits.hits[0]._source.protocol ? datum.metadata.hits.hits[0]._source.protocol : null\\\",\\n          \\\"as\\\": \\\"proto\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.metadata.hits.hits[0]._id ? datum.metadata.hits.hits[0]._id : null\\\",\\n          \\\"as\\\": \\\"log_id\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"project\\\",\\n          \\\"fields\\\": [\\\"key.src\\\", \\\"key.dst\\\", \\\"key.conn_state\\\", \\\"metadata.hits.hits[0]._source.source\\\", \\\"metadata.hits.hits[0]._source.destination\\\", \\\"proto\\\", \\\"metadata.hits.hits[0]._source.totDataBytes\\\", \\\"metadata.hits.hits[0]._source.timestamp\\\"],\\n          \\\"as\\\": [\\\"src\\\", \\\"dst\\\", \\\"conn_state\\\", \\\"source\\\", \\\"destination\\\", \\\"protocol\\\", \\\"total_bytes\\\", \\\"time\\\"] \\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"toString(datum.protocol)\\\",\\n          \\\"as\\\": \\\"proto_string\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\\"src\\\", \\\"dst\\\"],\\n          \\\"fields\\\":[\\\"proto\\\", \\\"total_bytes\\\"],\\n          \\\"ops\\\":[\\\"values\\\", \\\"mean\\\"],\\n          \\\"as\\\": [\\\"aggregated_objs\\\", \\\"byteAvg\\\"]\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"length(datum.aggregated_objs)\\\",\\n          \\\"as\\\": \\\"num_connections\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'conn_state') : null\\\",\\n          \\\"as\\\": \\\"conn_state\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'proto_string') : null\\\",\\n          \\\"as\\\": \\\"protocolArr\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'total_bytes') : null\\\",\\n          \\\"as\\\": \\\"bytesArr\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'time')[0] : null\\\",\\n          \\\"as\\\": \\\"timestamp\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'destination')[0] : null\\\", //hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_device\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'source')[0] : null\\\", //hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_device\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.aggregated_objs[0].destination.segment) ? toString(pluck(datum.aggregated_objs, 'destination.segment.name')[0]) : null\\\", //hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_segment\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.aggregated_objs[0].source.segment) ? toString(pluck(datum.aggregated_objs, 'source.segment.name')[0]) : null\\\", //hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_segment\\\"\\n        },\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"collapsyNodes\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"trigger\\\": \\\"clearCollapsed || initialRoot\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"clicked\\\",\\n          \\\"toggle\\\": \\\"clicked\\\"\\n        }\\n      ]\\n    },\\n    // Acts as the queue for the Breadth first traversal\\n    {\\n      \\\"name\\\": \\\"queue\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"insert\\\": \\\"{'id': initialRoot, 'depth': 0}\\\"\\n        },\\n        {\\n          \\\"trigger\\\": \\\"step\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"step\\\",\\n          \\\"insert\\\": \\\"data('next')\\\"\\n        }\\n      ]\\n    },\\n    // Tracks all visited nodes\\n    {\\n      \\\"name\\\": \\\"visited\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"insert\\\": \\\"{'src': null, 'dst': initialRoot, 'id': initialRoot, 'depth': 0, 'enrichment': initialRootData}\\\"\\n        },\\n        {\\n          \\\"trigger\\\": \\\"step\\\",\\n          \\\"insert\\\": \\\"data('next')\\\"\\n        },\\n      ],\\n      \\\"transform\\\":[\\n        // RootNode enrichment flattening - does not change enrichment transforms that are handled in table dataset \\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) ? length(datum.enrichment) : 0\\\",\\n          \\\"as\\\": \\\"enrich_len\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'proto_string') : datum.protocolArr\\\",\\n          \\\"as\\\": \\\"protocolArr\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'conn_state') : datum.conn_state\\\",\\n          \\\"as\\\": \\\"conn_state\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'destination')[0] : datum.dst_device\\\", // hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_device\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'source')[0] : datum.src_device\\\", // hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_device\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? toString(pluck(datum.enrichment, 'destination.segment')) : datum.dst_segment\\\", // hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_segment\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? toString(pluck(datum.enrichment, 'source.segment')) : datum.src_segment\\\", // hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_segment\\\"\\n        },\\n      ]\\n    },\\n    // Tracks what nodes to search next \\n    {\\n      \\\"name\\\": \\\"next\\\",\\n      \\\"source\\\": \\\"table\\\",\\n      \\\"transform\\\": [\\n        // Stop if we reach n\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"treeDepth < n\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"queue\\\",\\n          \\\"key\\\": \\\"id\\\",\\n          \\\"fields\\\": [\\n            \\\"src\\\" \\n          ],\\n          \\\"values\\\": [\\n            \\\"depth\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"parentDepth\\\"\\n          ]\\n        },\\n        // Keep valid ids in the queue\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"isValid(datum.parentDepth)\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.dst\\\", \\n          \\\"as\\\": \\\"id\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.parentDepth + 1\\\",\\n          \\\"as\\\": \\\"depth\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"visited\\\",\\n          \\\"key\\\": \\\"id\\\", \\n          \\\"fields\\\": [\\n            \\\"id\\\",\\n          ],\\n          \\\"as\\\": [\\n            \\\"visited\\\",\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"!isValid(datum.visited)\\\"\\n        },\\n        // Grab the parent node timestamp and insert into current node metadata\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.src === pluck(data('visited'), 'dst')[indexof(pluck(data('visited'), 'dst'), datum.src)] ? pluck(data('visited'), 'timestamp')[indexof(pluck(data('visited'), 'dst'), datum.src)] : null\\\",\\n          \\\"as\\\": \\\"parentTime\\\"\\n        },\\n        // time filter - filter out past timestamps (nodes)\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"timeFilter === 'On' && datum.depth > 1 ? datum.timestamp > datum.parentTime : 'Off'\\\", \\n        },\\n        // For `{(A,C),(B,C),(C,D)}` Vega doesn't know what `C` to put `D` on, we choose it based on lowest depth.\\n        {\\n          \\\"type\\\": \\\"window\\\",\\n          \\\"groupby\\\": [\\n            \\\"dst\\\", \\n            \\\"depth\\\"\\n          ],\\n          \\\"sort\\\": [\\n            {\\n              \\\"field\\\": \\\"parentDepth\\\",\\n              \\\"order\\\": \\\"ascending\\\"\\n            },\\n            {\\n              \\\"field\\\": \\\"src\\\", \\n              \\\"order\\\": \\\"ascending\\\"\\n            }\\n          ],\\n          \\\"ops\\\": [\\n            \\\"row_number\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"rank\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"datum.rank === 1\\\"\\n        }\\n      ]\\n    },\\n      // defines IP nodes and organizes data in tree data structure\\n    {\\n      \\\"name\\\": \\\"completeTree\\\",\\n      \\\"source\\\": [\\n        \\\"visited\\\"\\n      ],\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"src\\\", \\n            \\\"dst\\\" \\n          ],\\n          \\\"fields\\\": [\\\"protocolArr\\\"], // passes down enrichment data\\n          \\\"ops\\\": [\\\"values\\\"],\\n          \\\"as\\\": [\\\"enrichment\\\"]\\n        },\\n        {\\n          // hack to get initial root bind working. data sources aren't clearing. todo look into proper fix\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"(!isValid(datum.src) && datum.dst === initialRoot) || (data('completeTree').root.id === initialRoot)\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"stratify\\\",\\n          \\\"key\\\": \\\"dst\\\", \\n          \\\"parentKey\\\": \\\"src\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"tree\\\",\\n          \\\"method\\\": \\\"tidy\\\",\\n          \\\"size\\\": [\\n            {\\n              \\\"signal\\\": \\\"height\\\"\\n            },\\n            {\\n              \\\"signal\\\": \\\"width\\\"\\n            }\\n          ],\\n          \\\"separation\\\": true,\\n          \\\"as\\\": [\\n            \\\"y\\\",\\n            \\\"x\\\",\\n            \\\"depth\\\",\\n            \\\"children\\\"\\n          ]\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"ancestors\\\",\\n      \\\"source\\\": \\\"completeTree\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"treeAncestors('completeTree', datum.dst)\\\", \\n          \\\"as\\\": \\\"ancestors\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"flatten\\\",\\n          \\\"fields\\\": [\\n            \\\"ancestors\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"ancestor\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"datum.ancestor.dst !== datum.dst\\\" \\n        },\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"indata('collapsyNodes', 'id', datum.ancestor.dst)\\\" \\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"collapsed\\\",\\n      \\\"source\\\": \\\"ancestors\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"dst\\\" \\n          ]\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"visibleTree\\\",\\n      \\\"source\\\": \\\"completeTree\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"!indata('collapsed', 'dst', datum.dst)\\\" \\n        },\\n        {\\n          \\\"type\\\": \\\"stratify\\\",\\n          \\\"key\\\": \\\"dst\\\", \\n          \\\"parentKey\\\": \\\"src\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"tree\\\",\\n          \\\"method\\\": \\\"tidy\\\",\\n          \\\"size\\\": [\\n            {\\n              \\\"signal\\\": \\\"height - 100\\\"\\n            },\\n            {\\n              \\\"signal\\\": \\\"width - 220\\\"\\n            }\\n          ],\\n          \\\"separation\\\": true,\\n          \\\"as\\\": [\\n            \\\"y\\\",\\n            \\\"x\\\",\\n            \\\"depth\\\",\\n            \\\"children\\\"\\n          ]\\n        },\\n        // Creates device_array to determine which device info to show on node hover \\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"[pluck(datum.enrichment, 'dst_device')[0], pluck(datum.enrichment, 'src_device')[0]]\\\",\\n          \\\"as\\\": \\\"device_array\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"pluck(datum.enrichment, 'byteAvg')[0]\\\",\\n          \\\"as\\\": \\\"byteAvg\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"pluck(datum.enrichment, 'timestamp')[0]\\\", // grabs timestamp field value from enrichment object\\n          \\\"as\\\": \\\"ts\\\"\\n        },\\n        //converts timestamp into a Date object for humanreadable version of timestamp field\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datetime(year(datum.ts), month(datum.ts), date(datum.ts), hours(datum.ts), minutes(datum.ts), seconds(datum.ts), milliseconds(datum.ts))\\\",\\n          \\\"as\\\": \\\"date_obj\\\"\\n        },\\n\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"bytesExtent\\\",\\n      \\\"source\\\": \\\"visibleTree\\\",\\n      \\\"transform\\\":[\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"fields\\\": [\\\"byteAvg\\\", \\\"byteAvg\\\"],\\n          \\\"ops\\\":[\\\"min\\\", \\\"max\\\"],\\n          \\\"as\\\": [\\\"byteMin\\\", \\\"byteMax\\\"]\\n        },\\n      ]\\n    }\\n    {\\n      \\\"name\\\": \\\"timeExtent\\\",\\n      \\\"source\\\": \\\"visited\\\",\\n      \\\"transform\\\":[\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"fields\\\": [\\\"timestamp\\\", \\\"timestamp\\\"],\\n          \\\"ops\\\":[\\\"min\\\", \\\"max\\\"],\\n          \\\"as\\\": [\\\"timeMin\\\", \\\"timeMax\\\"]\\n        },\\n      ]\\n    }\\n    // Calculate paths between nodes\\n    {\\n      \\\"name\\\": \\\"links\\\",\\n      \\\"source\\\": \\\"visibleTree\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"treelinks\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"linkpath\\\",\\n          \\\"orient\\\": \\\"horizontal\\\",\\n          \\\"shape\\\": \\\"diagonal\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"pluck(datum.target.enrichment, 'byteAvg')[0]\\\",\\n          \\\"as\\\": \\\"byteAvg\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(datum.byteAvg - bytes_extent.min)/ (bytes_extent.max - bytes_extent.min)\\\",\\n          \\\"as\\\": \\\"byteAvg_normal\\\"\\n        },\\n\\n        ]\\n      },\\n    ],\\n    ## --------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 3: Scales -------------------------------------------------------------------------------------------------------\\n    ##  Maps data values to either categorical data or numerical data to change the way the data presents visually\\n    \\\"scales\\\": [\\n      // Assign a color for each layer\\n      {\\n        \\\"name\\\": \\\"color\\\",\\n        \\\"type\\\": \\\"linear\\\",\\n        \\\"range\\\": {\\n          \\\"scheme\\\": {\\\"signal\\\": \\\"nodeColor\\\"} // built in color scheme from Vega // observable10  set1 tableu1\\n        },\\n        \\\"domain\\\": [0,15], // hardcoded to fix infinite depth error\\n        \\\"zero\\\": true\\n      },\\n      {\\n        \\\"name\\\": \\\"dash_scale\\\",\\n        \\\"type\\\": \\\"ordinal\\\",\\n        \\\"domain\\\": [\\\"0 bytes transferred\\\", \\\"> 0 bytes transferred\\\"],\\n        \\\"range\\\": [[5,2], null]\\n      },\\n    ],\\n\\n    ## --------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 5: Marks --------------------------------------------------------------------------------------------------------\\n    ##  Determines how the data visually appears in the visualization\\n    \\\"marks\\\": [\\n      {\\n        // Render the tree inside a group to allow us to manipulate the entire position\\n        //Group mark made to standardize positioning of marks in visualization\\n        \\\"type\\\": \\\"group\\\",\\n        \\\"type\\\": \\\"group\\\",\\n        \\\"name\\\": \\\"treeGroup\\\",\\n        \\\"encode\\\": {\\n          \\\"enter\\\": {\\n            // Offset to make first IP visible\\n            \\\"x\\\": {\\n              \\\"value\\\": 400\\n            },\\n            \\\"height\\\": {\\n              \\\"signal\\\": \\\"height - 100\\\"\\n            },\\n            \\\"width\\\": {\\n              \\\"signal\\\": \\\"width\\\"\\n            }\\n          }\\n        },\\n        \\\"title\\\": {\\n          \\\"text\\\": \\\"IP Connections Tree Hierarchy\\\",\\n          \\\"orient\\\": \\\"top\\\",\\n          \\\"align\\\": \\\"center\\\"\\n        },\\n        \\\"marks\\\": [\\n          // Draw the paths\\n          {\\n            \\\"type\\\": \\\"path\\\",\\n            \\\"name\\\": \\\"nodePath\\\",\\n            \\\"zindex\\\": 0,\\n            \\\"from\\\": {\\n              \\\"data\\\": \\\"links\\\",\\n            },\\n            \\\"encode\\\": {\\n              \\\"update\\\": {\\n                \\\"path\\\": {\\n                  \\\"field\\\": \\\"path\\\"\\n                },\\n                \\\"stroke\\\": {\\n                  \\\"value\\\": \\\"#7777\\\"\\n                },\\n                \\\"strokeDash\\\":[\\n                  {\\n                  \\\"test\\\":\\\"datum.byteAvg == 0\\\",\\n                  \\\"value\\\": [10,5]\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"null\\\"\\n                  }\\n                ],\\n                \\\"strokeWidth\\\": {\\\"signal\\\": \\\"5 + (datum.byteAvg_normal * (20-5))\\\"}\\n              },\\n              \\\"hover\\\": {\\n                \\\"cursor\\\": {\\n                  \\\"value\\\": \\\"pointer\\\"\\n                },\\n                // Changes the link color on hover\\n                \\\"stroke\\\": {\\n                  \\\"value\\\": \\\"#aaa\\\"\\n                },\\n                \\\"tooltip\\\": {\\n                  \\\"signal\\\": \\\"{'Time': toString(datum.target.date_obj),'Src Segment': toString(pluck(datum.target.enrichment, 'src_segment')), 'Dst Segment': toString(pluck(datum.target.enrichment, 'src_segment')), 'Byte Avg': datum.byteAvg}\\\",\\n                }\\n              }\\n            }\\n          },\\n          {\\n            \\\"type\\\": \\\"rect\\\",\\n            \\\"name\\\": \\\"enrichmentBox\\\",\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                \\\"x\\\": {\\\"value\\\": -400},\\n                \\\"y\\\": {\\\"value\\\": 10},\\n                \\\"stroke\\\": {\\\"value\\\": \\\"black\\\"},\\n                \\\"strokeWidth\\\": {\\\"value\\\": 3},\\n                \\\"fill\\\": {\\\"value\\\": \\\"black\\\"},\\n              \\\"width\\\": {\\\"value\\\": 350},\\n                \\\"height\\\": {\\\"value\\\": 130},\\n              }\\n            }\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // title for enrichment box\\n          \\\"from\\\": {\\\"data\\\": \\\"links\\\"},\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                // \\\"align\\\": {\\\"value\\\": \\\"left\\\"},\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                \\\"fill\\\": {\\\"value\\\": \\\"white\\\"},\\n                \\\"opacity\\\": {\\\"value\\\": 0},\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"value\\\": -395}, \\n                \\\"y\\\": {\\\"value\\\":20},   \\n                \\\"text\\\": {\\\"signal\\\": \\\"enrichmentSrc + ' - ' + enrichmentDst\\\"},\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontStyle\\\": {\\\"value\\\": \\\"bold\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 16},\\n                \\\"opacity\\\": {\\\"signal\\\": \\\"isArray(enrichmentSrc) ? 1 : 0\\\" } // checks if enrichmentSrc is an array - if Array then text is an IP value and won't be [object Object] when opacity == 1\\n              },\\n            }\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // header for conn state, bytes, protocols\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                // \\\"align\\\": {\\\"value\\\": \\\"left\\\"},\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                \\\"fill\\\": {\\\"value\\\": \\\"white\\\"},\\n                \\\"opacity\\\": {\\\"value\\\": 0},\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"value\\\": -395}, \\n                \\\"y\\\": {\\\"value\\\": 40},   \\n                \\\"text\\\": {\\\"value\\\": \\\"Conn State   Bytes             Protocol\\\"},\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontStyle\\\": {\\\"value\\\": \\\"bold\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"opacity\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? 1 : 0\\\" } // checks if enrichmentSrc is an array - if Array then text is an IP value and won't be [object Object] when opacity == 1\\n              },\\n            }\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // conn state text in enrichment box\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                // \\\"align\\\": {\\\"value\\\": \\\"left\\\"},\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                \\\"fill\\\": {\\\"value\\\": \\\"white\\\"}\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"value\\\": -395}, \\n                \\\"y\\\": {\\\"value\\\": 60},   \\n                \\\"text\\\": {\\\"signal\\\": \\\"isArray(tooltip2) ? tooltip2 : 'Hover over node for node enrichment.' \\\"}, // checks if node enrichments is populated, if not display user instructions\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"opacity\\\": 1,\\n              }\\n            }\\n          },\\n          {\\n            \\\"type\\\": \\\"text\\\",     // total byte data text in enrichment box\\n              \\\"encode\\\": {\\n                \\\"enter\\\": {\\n                  \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                  \\\"fill\\\": {\\\"value\\\": \\\"white\\\"},\\n                },\\n                \\\"update\\\": {\\n                  \\\"x\\\": {\\\"value\\\": -300},\\n                  \\\"y\\\": {\\\"value\\\": 60},\\n                  \\\"text\\\": {\\\"signal\\\": \\\"byte_data\\\"},\\n                  \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                  \\\"fontSize\\\": {\\\"value\\\": 15},\\n                  \\\"opacity\\\": {\\\"signal\\\": \\\"isArray(byte_data) ? 1 : 0\\\" } // checks if byte_data is an array - if Array then text is an byte value and won't be [object Object] when opacity == 1\\n                }\\n              }\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // protocol text in enrichment box\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                \\\"fill\\\": {\\\"value\\\": \\\"white\\\"},\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? -205 : -395\\\"},\\n                \\\"y\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? 60 : 75\\\"},\\n                \\\"text\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? tooltip3 : 'Hover over link for link enrichment.' \\\"}, // checks if link enrichments is populated, if not display user instructions\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"opacity\\\": 1,\\n              }\\n            }\\n          },\\n          \\n          // Draw the nodes\\n          {\\n            \\\"type\\\": \\\"symbol\\\",\\n            \\\"name\\\": \\\"node\\\",\\n            \\\"zindex\\\": 10,\\n            \\\"from\\\": {\\n              \\\"data\\\": \\\"visibleTree\\\"\\n            },\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                \\\"size\\\": {\\n                  \\\"value\\\": 300\\n                },\\n                \\\"stroke\\\": {\\n                  \\\"value\\\": \\\"black\\\"\\n                },\\n              },\\n              \\\"hover\\\": {\\n                \\\"cursor\\\": {\\n                  \\\"value\\\": \\\"pointer\\\"\\n                },\\n              },\\n              \\\"update\\\": {\\n                // Make collapsed nodes larger\\n                \\\"size\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'id', datum.dst)\\\",\\n                    \\\"signal\\\": \\\"300 * 1.5\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"300\\\"\\n                  }\\n                ],\\n                // Stroke collapsed nodes\\n                \\\"strokeDash\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'id', datum.dst)\\\",\\n                    \\\"signal\\\": \\\"[5,3]\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"null\\\"\\n                  }\\n                ],\\n                \\\"strokeWidth\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'id', datum.dst)\\\",\\n                    \\\"signal\\\": \\\"4\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"0\\\"\\n                  }\\n                ],\\n                \\\"x\\\": {\\n                  \\\"field\\\": \\\"x\\\"\\n                },\\n                \\\"y\\\": {\\n                  \\\"field\\\": \\\"y\\\"\\n                },\\n                // Make collapsed nodes darker\\n                \\\"fill\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'id', datum.dst) || device_data.ip == datum.dst\\\",\\n                    \\\"signal\\\": \\\"rgb(rgb(scale('color', datum.depth)).r * 0.7, rgb(scale('color', datum.depth)).g * 0.7, rgb(scale('color', datum.depth)).b * 0.7)\\\"\\n                  },\\n                  {\\n                    \\\"scale\\\": \\\"color\\\",\\n                    \\\"field\\\": \\\"depth\\\"\\n                  }\\n                ],\\n                // tooltip must be declared in update instead of hover to prevent ip collisions\\n                \\\"tooltip\\\": {\\n                  \\\"signal\\\": \\\"device_info\\\",\\n                },\\n              },\\n              \\n            }\\n          },\\n          {\\n            // IP address labels for the nodes\\n            \\\"type\\\": \\\"text\\\",\\n            \\\"name\\\": \\\"nodeLabel\\\",\\n            \\\"zindex\\\": 10,\\n            \\\"from\\\": {\\n              \\\"data\\\": \\\"visibleTree\\\"\\n            },\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                \\\"text\\\": {\\n                  \\\"field\\\": \\\"dst\\\"\\n                },\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"baseline\\\": {\\n                  \\\"value\\\": \\\"middle\\\"\\n                }\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\n                  \\\"field\\\": \\\"x\\\"\\n                },\\n                \\\"y\\\": {\\n                  \\\"field\\\": \\\"y\\\"\\n                },\\n                // Collapsed or parents have labels on left\\n                \\\"dx\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'id', datum.dst) || datum.children\\\",\\n                    \\\"signal\\\": \\\"-1 * labelOffset\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"labelOffset\\\"\\n                  }\\n                ],\\n                \\\"align\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'id', datum.dst) || datum.children\\\",\\n                    \\\"signal\\\": \\\"'right'\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"'left'\\\"\\n                  }\\n                ],\\n                \\\"opacity\\\": 1\\n              },\\n              \\\"hover\\\": {\\n                \\\"cursor\\\": {\\n                  \\\"value\\\": \\\"pointer\\\"\\n                }\\n              }\\n            }\\n          }\\n      ]\\n      }\\n    ],\\n    \\\"legends\\\": [\\n      {\\n        \\\"title\\\": \\\"Average Bytes\\\",\\n        \\\"orient\\\": \\\"none\\\",\\n\\n        \\\"strokeDash\\\": \\\"dash_scale\\\",\\n        \\\"symbolType\\\": \\\"stroke\\\",\\n        \\\"symbolStrokeWidth\\\": 3,\\n        \\\"symbolSize\\\": 400,\\n        \\\"legendX\\\": 0,\\n        \\\"legendY\\\": { \\\"signal\\\": \\\"legend_height + 130\\\" },\\n\\n        \\\"encode\\\": {\\n          \\\"symbols\\\": {\\n            \\\"update\\\": {\\n              \\\"stroke\\\": { \\\"value\\\": \\\"#666\\\" },\\n              \\\"fillOpacity\\\": { \\\"value\\\": 0 }\\n            }\\n          },\\n          \\\"title\\\": {\\n            \\\"update\\\": {\\n              \\\"fontSize\\\": { \\\"value\\\": 14 }\\n            }\\n          },\\n          \\\"labels\\\": { \\\"update\\\": { \\\"fontSize\\\": { \\\"value\\\": 14 } } }\\n        }\\n      }\\n    ]\\n  }\\n\"}}"
      },
      "id": "ab8b2ef0-a2d3-11f0-b5ae-e139a66d2205",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-10-06T17:32:15.522Z",
      "version": "WzgxOCwxXQ=="
    }
  ],
  "version": "3.2.0"
}
