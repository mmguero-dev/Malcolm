{
  /**
    Authors:
      Mackenzie Zappe (mackenzie.zappe@inl.gov)
      Shelby Hiens
      Nicholas Donovan
    References:
      https://vega.github.io/vega/docs/
      https://vega.github.io/vega/examples/tree-layout/
    Commit:
      Corresponds to 9c2c5e7 in SMILE-Analytics/trees
  **/
  ##  Set up Vega specification definitions
  ##  Pay attention to Vega additions after V5
  // ## todo stop on broadcasts
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  // Make room for binds under the graph
  "autosize": {
    "type": "fit-x",
    "contains": "padding"
  },
  "padding": {
    "left": 5,
    "top": 5,
    "right": 5,
    "bottom": -100
  },
  ##  --------------------------------------------------------------------------------------------------------------------------
  ##  SECTION 0: Config --------------------------------------------------------------------------------------------------------
  ##  Define Specification constants like multiple instruction positioning
  ##  - arguments set in Config WILL be overwritten if redefined later in specification
  "config": {
    "signals": [
      // Adjust font scale based on display size
      {
        "name": "fontScale",
        "update": "clamp(min(width / 1920, height / 1080), 0.5, 1.3)"
      },
      {
        "name": "paddingScale",
        "update": "clamp(min(width / 1920, height / 1080), 0.5, 2)"
      },
      {
        "name": "labelFontSize",
        "init": "16 * fontScale"
      },
      {
        "name": "titleFontSize",
        "init": "20 * fontScale"
      },
      // Warn if data truncated
      {
        "name": "maxDataSize",
        "value": 10000
      },
      {
        "name": "dataMaxed",
        "update": "length(data('table')) >= maxDataSize"
      },
      {
        "name": "maxedWarning", // Warning to display to user if number of documents being processed exceeds 10k per Vega limitation
        "update": "dataMaxed ? warn('Maximum data response reached. Data may be truncated. Try adjusting timeframe.') : null"
      },
      {
        "name": "labelOffset",
        "value": 15
      }
    ],
    "axis": {
      "titleFontSize": {
        "signal": "titleFontSize"
      },
      "titlePadding": {
        "signal": "25 * paddingScale"
      },
      "labelFontSize": {
        "signal": "labelFontSize * .9"
      },
      "tickWidth": 3
    },
    "title": {
      "fontSize": {
        "signal": "titleFontSize * 1.2"
      }
    },
    "instruction": {
      "titleFontSize": {
        "signal": "titleFontSize * 0.9"
      },
      "labelFontSize": {
        "signal": "labelFontSize"
      },
      "padding": {
        "signal": "10 * paddingScale"
      }
    },
    "text": {
      "fontSize": {
        "signal": "labelFontSize * 0.9"
      },
      "baseline": "middle"
    },
    "rule": {
      "strokeWidth": 0.2,
      "stroke": "firebrick"
    }
  },
  ##  ---------------------------------------------------------------------------------------------------------------------------
  ##  SECTION 1: Signals --------------------------------------------------------------------------------------------------------
  ##  - Define dynamic variables (Signals) that can be updated at any point during the specification
  "signals": [
    //    logs into console run `VEGA_DEBUG.view.logLevel(3)` in console first
    //    {
    //      "name": "logger",
    //      "on": [
    //        {
    //          "events": {"signal":  "clear"},
    //          "update": "info(clear)"
    //        }
    //      ],
    //    },
    // Takes User Input to define the initial root
    {
      "name": "userInputRoot",
      "init": null,
      "bind": {
        "input": "search",
        "placeholder": "  x.x.x.x ", // place holder to show syntax to user - spaces used to center placeholder in bind box
        "name": "Root IP",
        "debounce": 1200
      }
    },
    // Finds the index of the root src IP
    {
      "name": "rootIndex",
      "update": "indexof(pluck(data('table'), 'src'), userInputRoot) "
    },

    // Pulls the src information based on the rootIndex and stores it as intitialRoot
    {
      "name": "initialRoot",
      "update": "pluck(data('table'), 'src')[rootIndex]",
    },

    // pulls enrichment data for the intialRoot based on rootIndex
    {
      "name": "initialRootData",
      "update": "pluck(data('table'), 'aggregated_objs')[rootIndex]",
    },

    {
      "name": "treeDepth",
      "update": "data('completeTree') && data('completeTree').root ? data('completeTree').root.height : -1"
    },
    // Allow the depth of the tree to be chosen
    {
      "name": "n",
      "init": 3,
      "bind": {
        "input": "range",
        "min": 1,
        "max": 15,
        "step": 1,
        "name": "Tree Height",
        "debounce": 300
      }
    },
    // time filter toggle
  {
    "name": "timeFilter",
    "init": "'Off'",
    "bind": {
      "input": "radio",
      "options": ["On", "Off"],
      "name": "Time Filter",
      "debounce": 300
    }
  },
  {
    "name": "On",
    "init": "",
    "debounce": 300
  },
  {
    "name": "Off",
    "update": "",
    "debounce": 300
  },
  // change scale for nodeColor
    {
      "name": "nodeColor",
      "init": "'set1'",
      "bind": {
        "input": "select",
        "options": ["observable10", "dark2", "paired", "set1"],
        "name": "Node Color",
        "debounce": 1200
      }
    },
    // Save n history as [previous, current]
    {
      "name": "nHist",
      "value": [
        3
      ],
      "on": [
        {
          "events": {
            "signal": "n"
          },
          "update": "slice(split(join(nHist)+','+n, ','), -2)"
        }
      ]
    },
    // Save previous n
    {
      "name": "nPrev",
      "update": "toNumber(nHist.length > 1 ? nHist[nHist.length-2] : nHist[0])"
    },
    // When n shrinks we need to clear the graph and rebuild the tree
    {
      "name": "clear",
      "init": "false",
      "on": [
        {
          "events": {
            "signal": "n"
          },
          "update": "n <= nPrev",
          "force": true
        },
      {
        "events": {
          "signal": "timeFilter"
        },
        "update": "timeFilter",
        "force": true
      },
      ]
    },
    // A counter that triggers the BF iteration
    {
      "name": "step",
      "value": 0,
      "on": [
        {
          // check the `update` condition every 50 ms
          "events": {
            "type": "timer",
            "throttle": 50
          },
          "update": "data('next') && length(data('next')) ? step + 1 : step"
        }
      ]
    },
    // Signals for collapsing a clicked node
    {
      "name": "clicked",
      "value": null,
      "on": [
        {
          "events": "@node:click",
          "update": "{'id': datum.dst}",
          "force": "true"
        },
        {
          "events": "@nodeLabel:click",
          "update": "{'id': datum.dst}",
          "force": "true"
        }
      ]
    },
    {
      "name": "clearCollapsed",
      "value": false,
      "on": [
        {
          "events": "dblclick[!event.item]",
          "update": "true",
          "force": true
        }
      ]
    },
    {
      "name": "count_num_connections",
      //"value": 0,
      //"init": "data(datum.proto)"
    },
    //Return the index of the device_array where the ip matches the current node's dst field
    {
      "name": "nodeEnrich",
      "value": {},
      "on":[
        {
          "events": "@node:mouseover",
          "update": "indexof(pluck(datum.device_array, 'ip'), datum.dst)",
          "force": "true",
        },
        {
          "events": "@node:mouseout",
          "update": "{}",
          "debounce": 1000,
        },
      ]
    },
    //Get the data at nodeEnrich index from the device_array
    {
      "name": "device_data",
      "value": "{'ip': null}", //declare initial as null to avoid startup error
      "on":[
        {
          "events": "@node:mouseover",
          "update": "datum.device_array[nodeEnrich]",
          "force": "true"
        },
        {
          "events": "@node:mouseout",
          "update": "{}",
          //"debounce": 1000,
        },
      ]
    },
    // Determine if netbox enrichment exists for a node and then pull the role value as a string
    {
      "name": "netbox_role",
      "on":[
        {
          "events": "@node:mouseover",
          "update": "device_data.device && device_data.device.role ? device_data.device.role[0] : null",
          "force": "true"
        },
      ]
    },
    // Determine if netbox enrichment exists for a node and then pull the name value as a string
    {
      "name": "netbox_name",
      "on":[
        {
          "events": "@node:mouseover",
          "update": "device_data.device && device_data.device.name ? device_data.device.name[0] : null",
          "force": "true"
        },

      ]
    },
    {
      "name": "device_mac",
      "on":[
        {
          "events": "@node:mouseover",
          "update": "device_data.mac ? device_data.mac[0] : null ",
          "force": "true"
        },

      ]
    },
    {
      "name": "device_oui",
      "on":[
        {
          "events": "@node:mouseover",
          "update": "device_data.oui ? device_data.oui : null",
          "force": true,
        }
      ]
    }
    // Format the node hover data so tooltip is populated
    {
      "name": "device_info",
      "on":[
        {
          "events": "@node:mouseover",
          "update": "{'IP': device_data.ip, 'MAC': device_mac, 'OUI': device_oui, 'As': device_data.as, 'Netbox Name': netbox_name,  'Nexbox Role': netbox_role }",
          "force": "true"
        },
        {
          "events": "@node:mouseout",
          "update": "{}",
          //"debounce": 1000,
        },
      ]
    },
    {
      "name": "color",
      "on":[
        {
          "events":"@node:mouseover",
          "update":"rgb(rgb(scale('color', datum.depth)).r * 0.7, rgb(scale('color', datum.depth)).g * 0.7, rgb(scale('color', datum.depth)).b * 0.7)"
        }
      ]
    },
    {
      "name": "tooltip2",
      "value": {},
      "on": [
        {"events": "path:mouseover", "update": "pluck(datum.target.enrichment, 'conn_state')" },
        {"events": "path:mouseout", "update": "{}"}
      ]
    },
    {
      "name": "tooltip3",
      "value": {},
      "on": [
        {"events": "path:mouseover", "update": "pluck(datum.target.enrichment, 'protocolArr')" },
        {"events": "path:mouseout", "update": "{}"}
      ]
    },
    {
      "name": "byte_data",
      "value": {},
      "on": [
        {"events": "path:mouseover", "update": "pluck(datum.target.enrichment, 'bytesArr')" },
        {"events": "path:mouseout", "update": "{}"}
      ]
    },
    {
      "name": "enrichmentSrc",
      "value": {},
      "on": [
        {"events": "path:mouseover", "update": "pluck(datum.target.enrichment, 'src')"},
        // {"events": "path:mouseover", "update": "{'src': datum.source.src, 'dst': datum.source.dst}" },
        {"events": "path:mouseout", "update": "{}"}
      ]
    },
    {
      "name": "enrichmentDst",
      "value": {},
      "on": [
        {"events": "path:mouseover", "update": "pluck(datum.target.enrichment, 'dst')"},
        // {"events": "path:mouseover", "update": "{'src': datum.source.src, 'dst': datum.source.dst}" },
        {"events": "path:mouseout", "update": "{}"}
      ]
    },
    {
      "name": "bytes_extent",
      "update": "{'min': pluck(data('bytesExtent'), 'byteMin')[0], 'max': pluck(data('bytesExtent'), 'byteMax')[0]}"
    },
  {
    "name": "time_extent",
    "update": "{'min': pluck(data('timeExtent'), 'timeMin'), 'max': pluck(data('timeExtent'), 'timeMax')}"
  },
    {
      "name": "connection_time",
      "value": {},
      "on": [
        {"events": "path:mouseover", "update": "datum.target.date_obj"},
        // {"events": "path:mouseover", "update": "{'src': datum.source.src, 'dst': datum.source.dst}" },
        {"events": "path:mouseout", "update": "{}"}
      ]
    },
    {
      "name": "legend_height", "value": 28
    },
  ],
  ## --------------------------------------------------------------------------------------------------------------------------
  ##  SECTION 2: DATA --------------------------------------------------------------------------------------------------------
  ##  Define datasets and data normalization to be worked with in schema
  "data": [
    {
      // 'Raw' data that is being pulled using opensearch dsl and aggregations capability
      // https://docs.opensearch.org/latest/query-dsl/
      // https://docs.opensearch.org/latest/aggregations/bucket/index/


      "name": "table",
      "url": {
        "index": "arkime_sessions3-*",
        "body": {
          "query": {
            "bool": {
              "must": [
                {
                  "match":{
                    "event.provider":"zeek",
                  },
                  "match":{
                    "event.dataset":"conn",
                  }
                }
                "%dashboard_context-must_clause%"
              ],
              "must_not": [
                "%dashboard_context-must_not_clause%"
              ],
              "filter": [
                "%dashboard_context-filter_clause%",
                {
                  "range": {
                    "@timestamp": {
                      "%timefilter%": true
                    }
                  }
                },
                {
                  "exists": {
                    "field": "event.id"
                  }
                },
                {
                  "exists": {
                    "field": "timestamp"
                  }
                },

            ]
          }
        },
        // assign all relevant destination ips to each unique source
        "aggs": {
        ##  Define parameters for
          "connections": {
            "composite": {
              "size": 10000,
              "sources": [
                {"src": { "terms": {"field": "source.ip"} } },
                {"dst": {"terms": {"field": "destination.ip"}} },
                // {"protocol": {"terms": {"field": "protocol"}} },
                {"conn_state": {"terms": {"field": "zeek.conn.conn_state"}}}
              ]
            },
              "aggs": {
                "metadata": {
                  "top_hits": {
                    "size": 1,
                    "_source": {
                      "includes": [
                        "source",
                        "destination",
                        "protocol",
                        "totDataBytes",
                        "timestamp",
                      ]
                    }
                  }
                }
              }
            }
          }
        }
        "size": 0
        // this applies to hits, not aggregations, faster and reduces data size
    },
    "format": {
      "property": "aggregations.connections.buckets"
    },
    "transform": [
      // surfaced aggregated objs, src and dst device, protocols, segment names, conn states in the metadata (prettification)
      {
        "type": "formula",
        "expr": "datum.metadata.hits.hits[0]._source.protocol ? datum.metadata.hits.hits[0]._source.protocol : null",
        "as": "proto"
      },
      {
        "type": "formula",
        "expr": "datum.metadata.hits.hits[0]._id ? datum.metadata.hits.hits[0]._id : null",
        "as": "log_id"
      },
      {
        "type": "project",
        "fields": ["key.src", "key.dst", "key.conn_state", "metadata.hits.hits[0]._source.source", "metadata.hits.hits[0]._source.destination", "proto", "metadata.hits.hits[0]._source.totDataBytes", "metadata.hits.hits[0]._source.timestamp"],
        "as": ["src", "dst", "conn_state", "source", "destination", "protocol", "total_bytes", "time"]
      },
      {
        "type":"formula",
        "expr": "toString(datum.protocol)",
        "as": "proto_string"
      },
      {
        "type": "aggregate",
        "groupby": ["src", "dst"],
        "fields":["proto", "total_bytes"],
        "ops":["values", "mean"],
        "as": ["aggregated_objs", "byteAvg"]
      },
      {
        "type":"formula",
        "expr": "length(datum.aggregated_objs)",
        "as": "num_connections"
      },
      {
        "type":"formula",
        "expr": "datum.aggregated_objs ? pluck(datum.aggregated_objs, 'conn_state') : null",
        "as": "conn_state"
      },
      {
        "type":"formula",
        "expr": "datum.aggregated_objs ? pluck(datum.aggregated_objs, 'proto_string') : null",
        "as": "protocolArr"
      },
      {
        "type":"formula",
        "expr": "datum.aggregated_objs ? pluck(datum.aggregated_objs, 'total_bytes') : null",
        "as": "bytesArr"
      },
      {
        "type":"formula",
        "expr": "datum.aggregated_objs ? pluck(datum.aggregated_objs, 'time')[0] : null",
        "as": "timestamp"
      },
      {
        "type":"formula",
        "expr": "datum.aggregated_objs ? pluck(datum.aggregated_objs, 'destination')[0] : null", //hardcoded to first index of objects because device is enriched from netbox not network traffic
        "as": "dst_device"
      },
      {
        "type":"formula",
        "expr": "datum.aggregated_objs ? pluck(datum.aggregated_objs, 'source')[0] : null", //hardcoded to first index of objects because device is enriched from netbox not network traffic
        "as": "src_device"
      },
      {
        "type":"formula",
        "expr": "isValid(datum.aggregated_objs[0].destination.segment) ? toString(pluck(datum.aggregated_objs, 'destination.segment.name')[0]) : null", //hardcoded to first index of objects because segment is enriched from netbox not network traffic
        "as": "dst_segment"
      },
      {
        "type":"formula",
        "expr": "isValid(datum.aggregated_objs[0].source.segment) ? toString(pluck(datum.aggregated_objs, 'source.segment.name')[0]) : null", //hardcoded to first index of objects because segment is enriched from netbox not network traffic
        "as": "src_segment"
      },
    ]
  },
  {
    "name": "collapsyNodes",
    "on": [
      {
        "trigger": "clearCollapsed || initialRoot",
        "remove": true
      },
      {
        "trigger": "clicked",
        "toggle": "clicked"
      }
    ]
  },
  // Acts as the queue for the Breadth first traversal
  {
    "name": "queue",
    "on": [
      {
        "trigger": "clear || initialRoot",
        "remove": true
      },
      {
        "trigger": "clear || initialRoot",
        "insert": "{'id': initialRoot, 'depth': 0}"
      },
      {
        "trigger": "step",
        "remove": true
      },
      {
        "trigger": "step",
        "insert": "data('next')"
      }
    ]
  },
  // Tracks all visited nodes
  {
    "name": "visited",
    "on": [
      {
        "trigger": "clear || initialRoot",
        "remove": true
      },
      {
        "trigger": "clear || initialRoot",
        "insert": "{'src': null, 'dst': initialRoot, 'id': initialRoot, 'depth': 0, 'enrichment': initialRootData}"
      },
      {
        "trigger": "step",
        "insert": "data('next')"
      },
    ],
    "transform":[
      // RootNode enrichment flattening - does not change enrichment transforms that are handled in table dataset
      {
        "type": "formula",
        "expr": "isValid(datum.enrichment) ? length(datum.enrichment) : 0",
        "as": "enrich_len"
      },
      {
        "type": "formula",
        "expr": "isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'proto_string') : datum.protocolArr",
        "as": "protocolArr"
      },
      {
        "type": "formula",
        "expr": "isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'conn_state') : datum.conn_state",
        "as": "conn_state"
      },
      {
        "type": "formula",
        "expr": "isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'destination')[0] : datum.dst_device", // hardcoded to first index of objects because device is enriched from netbox not network traffic
        "as": "dst_device"
      },
      {
        "type": "formula",
        "expr": "isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'source')[0] : datum.src_device", // hardcoded to first index of objects because device is enriched from netbox not network traffic
        "as": "src_device"
      },
      {
        "type": "formula",
        "expr": "isValid(datum.enrichment) && datum.enrich_len > 0 ? toString(pluck(datum.enrichment, 'destination.segment')) : datum.dst_segment", // hardcoded to first index of objects because segment is enriched from netbox not network traffic
        "as": "dst_segment"
      },
      {
        "type": "formula",
        "expr": "isValid(datum.enrichment) && datum.enrich_len > 0 ? toString(pluck(datum.enrichment, 'source.segment')) : datum.src_segment", // hardcoded to first index of objects because segment is enriched from netbox not network traffic
        "as": "src_segment"
      },
    ]
  },
  // Tracks what nodes to search next
  {
    "name": "next",
    "source": "table",
    "transform": [
      // Stop if we reach n
      {
        "type": "filter",
        "expr": "treeDepth < n"
      },
      {
        "type": "lookup",
        "from": "queue",
        "key": "id",
        "fields": [
          "src"
        ],
        "values": [
          "depth"
        ],
        "as": [
          "parentDepth"
        ]
      },
      // Keep valid ids in the queue
      {
        "type": "filter",
        "expr": "isValid(datum.parentDepth)"
      },
      {
        "type": "formula",
        "expr": "datum.dst",
        "as": "id"
      },
      {
        "type": "formula",
        "expr": "datum.parentDepth + 1",
        "as": "depth"
      },
      {
        "type": "lookup",
        "from": "visited",
        "key": "id",
        "fields": [
          "id",
        ],
        "as": [
          "visited",
        ]
      },
      {
        "type": "filter",
        "expr": "!isValid(datum.visited)"
      },
      // Grab the parent node timestamp and insert into current node metadata
      {
        "type": "formula",
        "expr": "datum.src === pluck(data('visited'), 'dst')[indexof(pluck(data('visited'), 'dst'), datum.src)] ? pluck(data('visited'), 'timestamp')[indexof(pluck(data('visited'), 'dst'), datum.src)] : null",
        "as": "parentTime"
      },
      // time filter - filter out past timestamps (nodes)
      {
        "type": "filter",
        "expr": "timeFilter === 'On' && datum.depth > 1 ? datum.timestamp > datum.parentTime : 'Off'",
      },
      // For `{(A,C),(B,C),(C,D)}` Vega doesn't know what `C` to put `D` on, we choose it based on lowest depth.
      {
        "type": "window",
        "groupby": [
          "dst",
          "depth"
        ],
        "sort": [
          {
            "field": "parentDepth",
            "order": "ascending"
          },
          {
            "field": "src",
            "order": "ascending"
          }
        ],
        "ops": [
          "row_number"
        ],
        "as": [
          "rank"
        ]
      },
      {
        "type": "filter",
        "expr": "datum.rank === 1"
      }
    ]
  },
    // defines IP nodes and organizes data in tree data structure
  {
    "name": "completeTree",
    "source": [
      "visited"
    ],
    "transform": [
      {
        "type": "aggregate",
        "groupby": [
          "src",
          "dst"
        ],
        "fields": ["protocolArr"], // passes down enrichment data
        "ops": ["values"],
        "as": ["enrichment"]
      },
      {
        // hack to get initial root bind working. data sources aren't clearing. todo look into proper fix
        "type": "filter",
        "expr": "(!isValid(datum.src) && datum.dst === initialRoot) || (data('completeTree').root.id === initialRoot)"
      },
      {
        "type": "stratify",
        "key": "dst",
        "parentKey": "src"
      },
      {
        "type": "tree",
        "method": "tidy",
        "size": [
          {
            "signal": "height"
          },
          {
            "signal": "width"
          }
        ],
        "separation": true,
        "as": [
          "y",
          "x",
          "depth",
          "children"
        ]
      }
    ]
  },
  {
    "name": "ancestors",
    "source": "completeTree",
    "transform": [
      {
        "type": "formula",
        "expr": "treeAncestors('completeTree', datum.dst)",
        "as": "ancestors"
      },
      {
        "type": "flatten",
        "fields": [
          "ancestors"
        ],
        "as": [
          "ancestor"
        ]
      },
      {
        "type": "filter",
        "expr": "datum.ancestor.dst !== datum.dst"
      },
      {
        "type": "filter",
        "expr": "indata('collapsyNodes', 'id', datum.ancestor.dst)"
      }
    ]
  },
  {
    "name": "collapsed",
    "source": "ancestors",
    "transform": [
      {
        "type": "aggregate",
        "groupby": [
          "dst"
        ]
      }
    ]
  },
  {
    "name": "visibleTree",
    "source": "completeTree",
    "transform": [
      {
        "type": "filter",
        "expr": "!indata('collapsed', 'dst', datum.dst)"
      },
      {
        "type": "stratify",
        "key": "dst",
        "parentKey": "src"
      },
      {
        "type": "tree",
        "method": "tidy",
        "size": [
          {
            "signal": "height - 100"
          },
          {
            "signal": "width - 220"
          }
        ],
        "separation": true,
        "as": [
          "y",
          "x",
          "depth",
          "children"
        ]
      },
      // Creates device_array to determine which device info to show on node hover
      {
        "type": "formula",
        "expr": "[pluck(datum.enrichment, 'dst_device')[0], pluck(datum.enrichment, 'src_device')[0]]",
        "as": "device_array"
      },
      {
        "type": "formula",
        "expr": "pluck(datum.enrichment, 'byteAvg')[0]",
        "as": "byteAvg"
      },
      {
        "type": "formula",
        "expr": "pluck(datum.enrichment, 'timestamp')[0]", // grabs timestamp field value from enrichment object
        "as": "ts"
      },
      //converts timestamp into a Date object for humanreadable version of timestamp field
      {
        "type": "formula",
        "expr": "datetime(year(datum.ts), month(datum.ts), date(datum.ts), hours(datum.ts), minutes(datum.ts), seconds(datum.ts), milliseconds(datum.ts))",
        "as": "date_obj"
      },

    ]
  },
  {
    "name": "bytesExtent",
    "source": "visibleTree",
    "transform":[
      {
        "type": "aggregate",
        "fields": ["byteAvg", "byteAvg"],
        "ops":["min", "max"],
        "as": ["byteMin", "byteMax"]
      },
    ]
  }
  {
    "name": "timeExtent",
    "source": "visited",
    "transform":[
      {
        "type": "aggregate",
        "fields": ["timestamp", "timestamp"],
        "ops":["min", "max"],
        "as": ["timeMin", "timeMax"]
      },
    ]
  }
  // Calculate paths between nodes
  {
    "name": "links",
    "source": "visibleTree",
    "transform": [
      {
        "type": "treelinks"
      },
      {
        "type": "linkpath",
        "orient": "horizontal",
        "shape": "diagonal"
      },
      {
        "type": "formula",
        "expr": "pluck(datum.target.enrichment, 'byteAvg')[0]",
        "as": "byteAvg"
      },
      {
        "type": "formula",
        "expr": "(datum.byteAvg - bytes_extent.min)/ (bytes_extent.max - bytes_extent.min)",
        "as": "byteAvg_normal"
      },

      ]
    },
  ],
  ## --------------------------------------------------------------------------------------------------------------------------
  ##  SECTION 3: Scales -------------------------------------------------------------------------------------------------------
  ##  Maps data values to either categorical data or numerical data to change the way the data presents visually
  "scales": [
    // Assign a color for each layer
    {
      "name": "color",
      "type": "linear",
      "range": {
        "scheme": {"signal": "nodeColor"} // built in color scheme from Vega // observable10  set1 tableu1
      },
      "domain": [0,15], // hardcoded to fix infinite depth error
      "zero": true
    },
    {
      "name": "dash_scale",
      "type": "ordinal",
      "domain": ["0 bytes transferred", "> 0 bytes transferred"],
      "range": [[5,2], null]
    },
  ],

  ## --------------------------------------------------------------------------------------------------------------------------
  ##  SECTION 5: Marks --------------------------------------------------------------------------------------------------------
  ##  Determines how the data visually appears in the visualization
  "marks": [
    {
      // Render the tree inside a group to allow us to manipulate the entire position
      //Group mark made to standardize positioning of marks in visualization
      "type": "group",
      "type": "group",
      "name": "treeGroup",
      "encode": {
        "enter": {
          // Offset to make first IP visible
          "x": {
            "value": 400
          },
          "height": {
            "signal": "height - 100"
          },
          "width": {
            "signal": "width"
          }
        }
      },
      "title": {
        "text": "IP Connections Tree Hierarchy",
        "orient": "top",
        "align": "center"
      },
      "marks": [
        // Draw the paths
        {
          "type": "path",
          "name": "nodePath",
          "zindex": 0,
          "from": {
            "data": "links",
          },
          "encode": {
            "update": {
              "path": {
                "field": "path"
              },
              "stroke": {
                "value": "#7777"
              },
              "strokeDash":[
                {
                "test":"datum.byteAvg == 0",
                "value": [10,5]
                },
                {
                  "signal": "null"
                }
              ],
              "strokeWidth": {"signal": "5 + (datum.byteAvg_normal * (20-5))"}
            },
            "hover": {
              "cursor": {
                "value": "pointer"
              },
              // Changes the link color on hover
              "stroke": {
                "value": "#aaa"
              },
              "tooltip": {
                "signal": "{'Time': toString(datum.target.date_obj),'Src Segment': toString(pluck(datum.target.enrichment, 'src_segment')), 'Dst Segment': toString(pluck(datum.target.enrichment, 'src_segment')), 'Byte Avg': datum.byteAvg}",
              }
            }
          }
        },
        {
          "type": "rect",
          "name": "enrichmentBox",
          "encode": {
            "enter": {
              "x": {"value": -400},
              "y": {"value": 10},
              "stroke": {"value": "black"},
              "strokeWidth": {"value": 3},
              "fill": {"value": "black"},
            "width": {"value": 350},
              "height": {"value": 130},
            }
          }
        },
        {
        "type": "text",     // title for enrichment box
        "from": {"data": "links"},
          "encode": {
            "enter": {
              // "align": {"value": "left"},
              "baseline": {"value": "top"},
              "fill": {"value": "white"},
              "opacity": {"value": 0},
            },
            "update": {
              "x": {"value": -395},
              "y": {"value":20},
              "text": {"signal": "enrichmentSrc + ' - ' + enrichmentDst"},
              "font": {"value": "Arial"},
              "fontStyle": {"value": "bold"},
              "fontSize": {"value": 16},
              "opacity": {"signal": "isArray(enrichmentSrc) ? 1 : 0" } // checks if enrichmentSrc is an array - if Array then text is an IP value and won't be [object Object] when opacity == 1
            },
          }
        },
        {
        "type": "text",     // header for conn state, bytes, protocols
          "encode": {
            "enter": {
              // "align": {"value": "left"},
              "baseline": {"value": "top"},
              "fill": {"value": "white"},
              "opacity": {"value": 0},
            },
            "update": {
              "x": {"value": -395},
              "y": {"value": 40},
              "text": {"value": "Conn State   Bytes             Protocol"},
              "font": {"value": "Arial"},
              "fontStyle": {"value": "bold"},
              "fontSize": {"value": 15},
              "opacity": {"signal": "isArray(tooltip3) ? 1 : 0" } // checks if enrichmentSrc is an array - if Array then text is an IP value and won't be [object Object] when opacity == 1
            },
          }
        },
        {
        "type": "text",     // conn state text in enrichment box
          "encode": {
            "enter": {
              // "align": {"value": "left"},
              "baseline": {"value": "top"},
              "fill": {"value": "white"}
            },
            "update": {
              "x": {"value": -395},
              "y": {"value": 60},
              "text": {"signal": "isArray(tooltip2) ? tooltip2 : 'Hover over node for node enrichment.' "}, // checks if node enrichments is populated, if not display user instructions
              "font": {"value": "Arial"},
              "fontSize": {"value": 15},
              "opacity": 1,
            }
          }
        },
        {
          "type": "text",     // total byte data text in enrichment box
            "encode": {
              "enter": {
                "baseline": {"value": "top"},
                "fill": {"value": "white"},
              },
              "update": {
                "x": {"value": -300},
                "y": {"value": 60},
                "text": {"signal": "byte_data"},
                "font": {"value": "Arial"},
                "fontSize": {"value": 15},
                "opacity": {"signal": "isArray(byte_data) ? 1 : 0" } // checks if byte_data is an array - if Array then text is an byte value and won't be [object Object] when opacity == 1
              }
            }
        },
        {
        "type": "text",     // protocol text in enrichment box
          "encode": {
            "enter": {
              "baseline": {"value": "top"},
              "fill": {"value": "white"},
            },
            "update": {
              "x": {"signal": "isArray(tooltip3) ? -205 : -395"},
              "y": {"signal": "isArray(tooltip3) ? 60 : 75"},
              "text": {"signal": "isArray(tooltip3) ? tooltip3 : 'Hover over link for link enrichment.' "}, // checks if link enrichments is populated, if not display user instructions
              "font": {"value": "Arial"},
              "fontSize": {"value": 15},
              "opacity": 1,
            }
          }
        },

        // Draw the nodes
        {
          "type": "symbol",
          "name": "node",
          "zindex": 10,
          "from": {
            "data": "visibleTree"
          },
          "encode": {
            "enter": {
              "size": {
                "value": 300
              },
              "stroke": {
                "value": "black"
              },
            },
            "hover": {
              "cursor": {
                "value": "pointer"
              },
            },
            "update": {
              // Make collapsed nodes larger
              "size": [
                {
                  "test": "indata('collapsyNodes', 'id', datum.dst)",
                  "signal": "300 * 1.5"
                },
                {
                  "signal": "300"
                }
              ],
              // Stroke collapsed nodes
              "strokeDash": [
                {
                  "test": "indata('collapsyNodes', 'id', datum.dst)",
                  "signal": "[5,3]"
                },
                {
                  "signal": "null"
                }
              ],
              "strokeWidth": [
                {
                  "test": "indata('collapsyNodes', 'id', datum.dst)",
                  "signal": "4"
                },
                {
                  "signal": "0"
                }
              ],
              "x": {
                "field": "x"
              },
              "y": {
                "field": "y"
              },
              // Make collapsed nodes darker
              "fill": [
                {
                  "test": "indata('collapsyNodes', 'id', datum.dst) || device_data.ip == datum.dst",
                  "signal": "rgb(rgb(scale('color', datum.depth)).r * 0.7, rgb(scale('color', datum.depth)).g * 0.7, rgb(scale('color', datum.depth)).b * 0.7)"
                },
                {
                  "scale": "color",
                  "field": "depth"
                }
              ],
              // tooltip must be declared in update instead of hover to prevent ip collisions
              "tooltip": {
                "signal": "device_info",
              },
            },

          }
        },
        {
          // IP address labels for the nodes
          "type": "text",
          "name": "nodeLabel",
          "zindex": 10,
          "from": {
            "data": "visibleTree"
          },
          "encode": {
            "enter": {
              "text": {
                "field": "dst"
              },
              "fontSize": {"value": 15},
              "font": {"value": "Arial"},
              "baseline": {
                "value": "middle"
              }
            },
            "update": {
              "x": {
                "field": "x"
              },
              "y": {
                "field": "y"
              },
              // Collapsed or parents have labels on left
              "dx": [
                {
                  "test": "indata('collapsyNodes', 'id', datum.dst) || datum.children",
                  "signal": "-1 * labelOffset"
                },
                {
                  "signal": "labelOffset"
                }
              ],
              "align": [
                {
                  "test": "indata('collapsyNodes', 'id', datum.dst) || datum.children",
                  "signal": "'right'"
                },
                {
                  "signal": "'left'"
                }
              ],
              "opacity": 1
            },
            "hover": {
              "cursor": {
                "value": "pointer"
              }
            }
          }
        }
    ]
    }
  ],
  "legends": [
    {
      "title": "Average Bytes",
      "orient": "none",

      "strokeDash": "dash_scale",
      "symbolType": "stroke",
      "symbolStrokeWidth": 3,
      "symbolSize": 400,
      "legendX": 0,
      "legendY": { "signal": "legend_height + 130" },

      "encode": {
        "symbols": {
          "update": {
            "stroke": { "value": "#666" },
            "fillOpacity": { "value": 0 }
          }
        },
        "title": {
          "update": {
            "fontSize": { "value": 14 }
          }
        },
        "labels": { "update": { "fontSize": { "value": 14 } } }
      }
    }
  ]
}