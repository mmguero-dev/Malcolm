{
  "objects": [
    {
      "attributes": {
        "description": "",
        "hits": 0,
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"language\":\"kuery\",\"query\":\"\"},\"filter\":[]}"
        },
        "optionsJSON": "{\"hidePanelTitles\":false,\"useMargins\":true}",
        "panelsJSON": "[{\"embeddableConfig\":{},\"gridData\":{\"h\":21,\"i\":\"edc8a59c-bc1a-4af8-a711-6ba85932402e\",\"w\":6,\"x\":0,\"y\":0},\"panelIndex\":\"edc8a59c-bc1a-4af8-a711-6ba85932402e\",\"version\":\"3.2.0\",\"panelRefName\":\"panel_0\"},{\"embeddableConfig\":{},\"gridData\":{\"h\":24,\"i\":\"c29b20ef-883e-4298-8cd9-b5d534d1a145\",\"w\":21,\"x\":6,\"y\":0},\"panelIndex\":\"c29b20ef-883e-4298-8cd9-b5d534d1a145\",\"version\":\"3.2.0\",\"panelRefName\":\"panel_1\"},{\"embeddableConfig\":{},\"gridData\":{\"h\":24,\"i\":\"51c59c00-4788-420d-8932-df25859050df\",\"w\":21,\"x\":27,\"y\":0},\"panelIndex\":\"51c59c00-4788-420d-8932-df25859050df\",\"version\":\"3.2.0\",\"panelRefName\":\"panel_2\"},{\"embeddableConfig\":{\"hidePanelTitles\":true},\"gridData\":{\"h\":3,\"i\":\"f37f539d-3c78-447b-8a01-1979c5c42388\",\"w\":6,\"x\":0,\"y\":21},\"panelIndex\":\"f37f539d-3c78-447b-8a01-1979c5c42388\",\"version\":\"3.2.0\",\"panelRefName\":\"panel_3\"},{\"embeddableConfig\":{},\"gridData\":{\"h\":37,\"i\":\"321d06b6-bc23-4573-9610-cae33b2ab64f\",\"w\":48,\"x\":0,\"y\":24},\"panelIndex\":\"321d06b6-bc23-4573-9610-cae33b2ab64f\",\"version\":\"3.2.0\",\"panelRefName\":\"panel_4\"}]",
        "timeRestore": false,
        "title": "VADR - Force Directed",
        "version": 1
      },
      "id": "ac8b32c0-be66-11ef-9ff5-ff2a2927176e",
      "migrationVersion": {
        "dashboard": "7.9.3"
      },
      "namespaces": [
        "default"
      ],
      "references": [
        {
          "id": "4fdd16a0-3334-11ef-94c9-09db3014d49a",
          "name": "panel_0",
          "type": "visualization"
        },
        {
          "id": "32c684e0-be65-11ef-9ff5-ff2a2927176e",
          "name": "panel_1",
          "type": "visualization"
        },
        {
          "id": "02ef18f0-bd97-11ef-b43b-112c1ca27e0b",
          "name": "panel_2",
          "type": "visualization"
        },
        {
          "id": "a57e8860-3116-11f0-af4f-052f357bea07",
          "name": "panel_3",
          "type": "visualization"
        },
        {
          "id": "638d9e80-be63-11ef-9ff5-ff2a2927176e",
          "name": "panel_4",
          "type": "visualization"
        }
      ],
      "type": "dashboard",
      "updated_at": "2025-10-20T19:34:57.690Z",
      "version": "WzE2MTYsMV0="
    },
    {
      "attributes": {
        "description": "",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":{\"query_string\":{\"query\":\"*\"}},\"language\":\"lucene\"},\"filter\":[]}"
        },
        "title": "VADR Network Logs",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"VADR Network Logs\",\"type\":\"markdown\",\"aggs\":[],\"params\":{\"markdown\":\"### VADR Toolkit  \\n[Inventory](#/dashboard/d16105d0-2b75-11f0-92dc-5f54cacd4f4e)   \\n[Misconfigurations](#dashboard/f75511b0-2b79-11f0-92dc-5f54cacd4f4e)   \\n[Outdated/Insecure Services](#/dashboard/62ac0aa0-2b9c-11f0-bb82-8ffd215e5a91)  \\n[Remote Access](#/dashboard/985cb6a0-2ba0-11f0-bb82-8ffd215e5a91)    \\n[External Communications](#/dashboard/5cd4b680-2b8e-11f0-92dc-5f54cacd4f4e)   \\n[Domain Queries](#/dashboard/82e4ebe0-2d11-11f0-af4f-052f357bea07)     \\n[Network Time Protocol](#/dashboard/444a06e0-adea-11f0-96f4-a1d36a85a6ea)     \\n[Intrusion Detection Alerts](#/dashboard/8444dee0-3023-11f0-af4f-052f357bea07)     \\n[Segment Examiner](#/dashboard/0f52b420-9e08-11ef-8358-f36ccc4ae837)     \\n[Sankey Tool](#/dashboard/0fb588c0-2d0f-11f0-af4f-052f357bea07)     \\n[Force Directed Tool - Beta](#/dashboard/ac8b32c0-be66-11ef-9ff5-ff2a2927176e)     \\n[NAVV](#/dashboard/11cd7300-fc34-11ee-a696-1ddfa039ab2d)    \\n[Legacy Analysis](#/dashboard/590fcc10-fe8f-11ee-99f0-3db6323f1fae)    \\n\\nMALCOLM_NAVIGATION_MARKDOWN_REPLACER\",\"type\":\"markdown\",\"fontSize\":10,\"openLinksInNewTab\":false}}"
      },
      "id": "4fdd16a0-3334-11ef-94c9-09db3014d49a",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-10-20T19:25:34.461Z",
      "version": "WzE2MTEsMV0="
    },
    {
      "attributes": {
        "description": "",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":\"   event.dataset:(dns OR conn) AND NOT source.ip:169.254.0.0/16  AND NOT destination.ip:(224.0.0.0/16 OR 255.0.0.0/8 OR 239.0.0.0/8) AND NOT network.type:\\\"ipv6\\\"\",\"language\":\"kuery\"},\"filter\":[]}"
        },
        "title": "VADR - Segment Force Directed",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"VADR - Segment Force Directed\",\"type\":\"vega\",\"aggs\":[],\"params\":{\"spec\":\"{\\n  \\\"$schema\\\": \\\"https://vega.github.io/schema/vega/v5.json\\\",\\n  \\\"description\\\": \\\"Force-Directed Network Graph with data from Malcolm\\\",\\n  \\\"autosize\\\": \\\"fit\\\",\\n  \\\"background\\\": \\\"darkslategray\\\",\\n  \\\"signals\\\": [\\n    {\\n      \\\"name\\\": \\\"xrange\\\",\\n      \\\"update\\\": \\\"[0, width]\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"yrange\\\",\\n      \\\"update\\\": \\\"[height, 0]\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"xext\\\",\\n      \\\"update\\\": \\\"[0, width]\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"yext\\\",\\n      \\\"update\\\": \\\"[height, 0]\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"click\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:dblclick!\\\",\\n          \\\"update\\\": \\\"opensearchDashboardsAddFilter({\\\\\\\"match_phrase\\\\\\\": { \\\\\\\"source.segment.name\\\\\\\": datum.segment } }, 'MALCOLM_NETWORK_INDEX_PATTERN_REPLACER')\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"down\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mouseup,touchend\\\",\\n          \\\"update\\\": \\\"null\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart\\\",\\n          \\\"update\\\": \\\"xy()\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"symbol:mousedown, symbol:touchstart\\\",\\n          \\\"update\\\": \\\"null\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"xcur\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart, touchend\\\",\\n          \\\"update\\\": \\\"xdom\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"ycur\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart, touchend\\\",\\n          \\\"update\\\": \\\"ydom\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"delta\\\",\\n      \\\"value\\\": [0, 0],\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"window\\\",\\n              \\\"type\\\": \\\"mousemove\\\",\\n              \\\"consume\\\": true,\\n              \\\"between\\\": [\\n                {\\n                  \\\"type\\\": \\\"mousedown\\\"\\n                },\\n                {\\n                  \\\"source\\\": \\\"window\\\",\\n                  \\\"type\\\": \\\"mouseup\\\"\\n                }\\n              ]\\n            },\\n            {\\n              \\\"type\\\": \\\"touchmove\\\",\\n              \\\"consume\\\": true,\\n              \\\"filter\\\": \\\"event.touches.length === 1\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"down ? [down[0]-x(), y()-down[1]] : [0,0]\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"anchor\\\",\\n      \\\"value\\\": [0, 0],\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"wheel\\\",\\n          \\\"update\\\": \\\"[invert('xscale', x()), invert('yscale', y())]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchstart\\\",\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"[(xdom[0] + xdom[1]) / 2, (ydom[0] + ydom[1]) / 2]\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"zoom\\\",\\n      \\\"value\\\": 1,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"wheel!\\\",\\n          \\\"force\\\": true,\\n          \\\"update\\\": \\\"pow(1.001, event.deltaY * pow(16, event.deltaMode))\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"dist2\\\"\\n          },\\n          \\\"force\\\": true,\\n          \\\"update\\\": \\\"dist1 / dist2\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"1\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"dist1\\\",\\n      \\\"value\\\": 0,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchstart\\\",\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"pinchDistance(event)\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"dist2\\\"\\n          },\\n          \\\"update\\\": \\\"dist2\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"dist2\\\",\\n      \\\"value\\\": 0,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchmove\\\",\\n            \\\"consume\\\": true,\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"pinchDistance(event)\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"xdom\\\",\\n      \\\"update\\\": \\\"xext\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"delta\\\"\\n          },\\n          \\\"update\\\": \\\"[xcur[0] + span(xcur) * delta[0] / width, xcur[1] + span(xcur) * delta[0] / width]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"zoom\\\"\\n          },\\n          \\\"update\\\": \\\"[anchor[0] + (xdom[0] - anchor[0]) * zoom, anchor[0] + (xdom[1] - anchor[0]) * zoom]\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"xrange\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"ydom\\\",\\n      \\\"update\\\": \\\"yext\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"delta\\\"\\n          },\\n          \\\"update\\\": \\\"[ycur[0] + span(ycur) * delta[1] / height, ycur[1] + span(ycur) * delta[1] / height]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"zoom\\\"\\n          },\\n          \\\"update\\\": \\\"[anchor[1] + (ydom[0] - anchor[1]) * zoom, anchor[1] + (ydom[1] - anchor[1]) * zoom]\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"yrange\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"size\\\",\\n      \\\"update\\\": \\\"clamp(20 / span(xdom), 1, 1000)\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"cx\\\",\\n      \\\"update\\\": \\\"width / 2\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"[symbol:mousedown, window:mouseup] > window:mousemove\\\",\\n          \\\"update\\\": \\\"cx==width/2?cx+0.001:width/2\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"cy\\\",\\n      \\\"update\\\": \\\"height / 2\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"nodeRadiusKey\\\",\\n      \\\"description\\\": \\\"q=increase size, a=decrease size\\\",\\n      \\\"value\\\": 2,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"window:keypress\\\",\\n          \\\"update\\\": \\\"event.key=='a'&&nodeRadiusKey>1?nodeRadiusKey-1:event.key=='q'?nodeRadiusKey+1:nodeRadiusKey\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"nodeRadius\\\",\\n      \\\"value\\\": 12,\\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"range\\\",\\n        \\\"min\\\": 1,\\n        \\\"max\\\": 50,\\n        \\\"step\\\": 1\\n      },\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"nodeRadiusKey\\\"\\n          },\\n          \\\"update\\\": \\\"nodeRadiusKey\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"nodeCharge\\\",\\n      \\\"value\\\": -50,\\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"range\\\",\\n        \\\"min\\\": -100,\\n        \\\"max\\\": 10,\\n        \\\"step\\\": 1\\n      }\\n    },\\n    {\\n      \\\"name\\\": \\\"linkDistance\\\",\\n      \\\"value\\\": 80\\n    },\\n    {\\n      \\\"description\\\": \\\"State variable for active link fix status.\\\",\\n      \\\"name\\\": \\\"fix_link\\\",\\n      \\\"value\\\": false,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"path:mouseout[!event.buttons], window:mouseup\\\",\\n          \\\"update\\\": \\\"false\\\"\\n        },\\n        {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"fix_link || true\\\", \\\"force\\\": true},\\n        {\\n          \\\"events\\\": \\\"[path:mousedown, window:mouseup] > window:mousemove!\\\",\\n          \\\"update\\\": \\\"xy()\\\",\\n          \\\"force\\\": true\\n        }\\n      ]\\n    },\\n    {\\n      \\\"description\\\": \\\"State variable for active node fix status.\\\",\\n      \\\"name\\\": \\\"fix\\\",\\n      \\\"value\\\": false,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:mouseout[!event.buttons], window:mouseup\\\",\\n          \\\"update\\\": \\\"false\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"symbol:mouseover\\\",\\n          \\\"update\\\": \\\"fix || true\\\",\\n          \\\"force\\\": true\\n        },\\n        {\\n          \\\"events\\\": \\\"[symbol:mousedown, window:mouseup] > window:mousemove!\\\",\\n          \\\"update\\\": \\\"xy()\\\",\\n          \\\"force\\\": true\\n        }\\n      ]\\n    },\\n    {\\n      \\\"description\\\": \\\"Graph node most recently interacted with.\\\",\\n      \\\"name\\\": \\\"node\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:mouseover\\\",\\n          \\\"update\\\": \\\"fix === true ? datum.index : node\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"nodeHover\\\",\\n      \\\"value\\\": {\\n        \\\"id\\\": null,\\n        \\\"connections\\\": []\\n      },\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:mouseover\\\",\\n          \\\"update\\\": \\\"{'id':datum.index, 'connections':split(datum.sources+','+datum.targets,',')}\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"symbol:mouseout\\\",\\n          \\\"update\\\": \\\"{'id':null, 'connections':[]}\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"description\\\": \\\"Graph link most recently interacted with.\\\",\\n      \\\"name\\\": \\\"link\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"path:mouseover\\\",\\n          \\\"update\\\": \\\"fix_link === true ? datum.index : link\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"linkHover\\\",\\n      \\\"value\\\": {\\n        \\\"direction\\\": null,\\n        \\\"connection\\\": null,\\n      },\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"path:mouseover\\\",\\n          \\\"update\\\": \\\"{'id': datum.index}\\\"\\n              \\n          \\n        },\\n        {\\n          \\\"events\\\": \\\"path:mouseout\\\",\\n          \\\"update\\\": \\\"{'id':null}\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"description\\\": \\\"Flag to restart Force simulation upon data changes.\\\",\\n      \\\"name\\\": \\\"restart\\\",\\n      \\\"value\\\": false,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"fix\\\"\\n          },\\n          \\\"update\\\": \\\"fix && fix.length\\\"\\n        }\\n      ]\\n    }\\n  ],\\n  \\\"data\\\": [\\n    {\\n      \\\"name\\\": \\\"raw-data\\\",\\n      \\\"url\\\": {\\n        \\\"%context%\\\": true,\\n        \\\"%timefield%\\\": \\\"MALCOLM_NETWORK_INDEX_TIME_FIELD_REPLACER\\\",\\n        \\\"index\\\": \\\"MALCOLM_NETWORK_INDEX_PATTERN_REPLACER\\\",\\n        \\\"body\\\": {\\n          \\\"size\\\": 0,\\n          \\\"aggs\\\": {\\n            \\\"connections\\\": {\\n              \\\"composite\\\": {\\n                \\\"size\\\": 1000,\\n                \\\"sources\\\": [\\n                  {\\n                    \\\"src\\\": {\\n                      \\\"terms\\\": {\\n                        \\\"field\\\": \\\"source.segment.name\\\"\\n                      }\\n                    }\\n                  },\\n                  {\\n                    \\\"dst\\\": {\\n                      \\\"terms\\\": {\\n                        \\\"field\\\": \\\"destination.segment.name\\\"\\n                      }\\n                    }\\n                  }\\n                ]\\n              },\\n              \\\"aggs\\\": {\\n                \\\"top_tags\\\": {\\n                  \\\"top_hits\\\": {\\n                    \\\"size\\\": 1,\\n                    \\\"_source\\\": {\\n                      \\\"includes\\\": [\\n                        \\\"tags\\\",\\n                        \\\"source.segment.name\\\",\\n                        \\\"destination.segment.name\\\"\\n                      ]\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      },\\n      \\\"format\\\": {\\n        \\\"property\\\": \\\"aggregations.connections.buckets\\\"\\n      }\\n    },\\n    {\\n      \\\"name\\\": \\\"link-data-raw\\\",\\n      \\\"source\\\": \\\"raw-data\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"source\\\",\\n          \\\"expr\\\": \\\"datum.key.src\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"target\\\",\\n          \\\"expr\\\": \\\"datum.key.dst\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"value\\\",\\n          \\\"expr\\\": \\\"datum.doc_count\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"tags\\\",\\n          \\\"expr\\\": \\\"datum.top_tags.hits.hits[0]._source.tags\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"window\\\",\\n          \\\"ops\\\": [\\n            \\\"row_number\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"index\\\"\\n          ]\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"link-data\\\",\\n      \\\"source\\\": \\\"link-data-raw\\\"\\n    },\\n    \\n    {\\n      \\\"name\\\": \\\"source-connections\\\",\\n      \\\"source\\\": \\\"link-data-raw\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"source\\\"\\n          ],\\n          \\\"ops\\\": [\\n            \\\"values\\\"\\n          ],\\n          \\\"fields\\\": [\\n            \\\"target\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"connections\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"targets\\\",\\n          \\\"expr\\\": \\\"pluck(datum.connections, 'target')\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"target-connections\\\",\\n      \\\"source\\\": \\\"link-data-raw\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"target\\\"\\n          ],\\n          \\\"ops\\\": [\\n            \\\"values\\\"\\n          ],\\n          \\\"fields\\\": [\\n            \\\"source\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"connections\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"sources\\\",\\n          \\\"expr\\\": \\\"pluck(datum.connections, 'source')\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"node-data-raw\\\",\\n      \\\"source\\\": \\\"raw-data\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"source\\\",\\n          \\\"expr\\\": \\\"datum.key.src\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"target\\\",\\n          \\\"expr\\\": \\\"datum.key.dst\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"value\\\",\\n          \\\"expr\\\": \\\"datum.doc_count\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"tags\\\",\\n          \\\"expr\\\": \\\"datum.top_tags.hits.hits[0]._source.tags\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"fold\\\",\\n          \\\"fields\\\": [\\n            \\\"source\\\",\\n            \\\"target\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"key\\\",\\n            \\\"segment\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"segment\\\"\\n          ],\\n          \\\"ops\\\": [\\n            \\\"sum\\\",\\n            \\\"values\\\"\\n          ],\\n          \\\"fields\\\": [\\n            \\\"value\\\",\\n            \\\"tags\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"doc_count\\\",\\n            \\\"tagsCollector\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"flatten\\\",\\n          \\\"fields\\\": [\\n            \\\"tagsCollector\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"oneTag\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"segment\\\"\\n          ],\\n          \\\"ops\\\": [\\n            \\\"distinct\\\",\\n            \\\"max\\\"\\n          ],\\n          \\\"fields\\\": [\\n            \\\"oneTag\\\",\\n            \\\"doc_count\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"tags\\\",\\n            \\\"doc_count\\\"\\n          ]\\n        },/*\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"name\\\",\\n          \\\"expr\\\": \\\"datum.segment\\\"\\n        },*/\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"group\\\",\\n          \\\"expr\\\": \\\"length(datum.tags) && datum.tags[0] ? datum.tags[0] : 'No Tag'\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"window\\\",\\n          \\\"ops\\\": [\\n            \\\"row_number\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"index\\\"\\n          ]\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"node-data\\\",\\n      \\\"source\\\": \\\"node-data-raw\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"source-connections\\\",\\n          \\\"key\\\": \\\"source\\\",\\n          \\\"fields\\\": [\\n            \\\"segment\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"targets\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"targets\\\"\\n          ],\\n          \\\"default\\\": [\\n            \\\"\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"target-connections\\\",\\n          \\\"key\\\": \\\"target\\\",\\n          \\\"fields\\\": [\\n            \\\"segment\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"sources\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"sources\\\"\\n          ],\\n          \\\"default\\\": [\\n            \\\"\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"force\\\",\\n          \\\"iterations\\\": 600,\\n          \\\"restart\\\": {\\n            \\\"signal\\\": \\\"restart\\\"\\n          },\\n          \\\"velocityDecay\\\": 0.7,\\n          \\\"signal\\\": \\\"force\\\",\\n          \\\"forces\\\": [\\n            {\\n              \\\"force\\\": \\\"center\\\",\\n              \\\"x\\\": {\\n                \\\"signal\\\": \\\"cx\\\"\\n              },\\n              \\\"y\\\": {\\n                \\\"signal\\\": \\\"cy\\\"\\n              }\\n            },\\n            {\\n              \\\"force\\\": \\\"x\\\",\\n              \\\"x\\\": {\\n                \\\"expr\\\": \\\"width/2\\\"\\n              },\\n              \\\"strength\\\": 0.0015\\n            },\\n            {\\n              \\\"force\\\": \\\"y\\\",\\n              \\\"y\\\": {\\n                \\\"expr\\\": \\\"height/2\\\"\\n              },\\n              \\\"strength\\\": 0.0015\\n            },\\n            {\\n              \\\"force\\\": \\\"collide\\\",\\n              \\\"radius\\\": {\\\"signal\\\": \\\"sqrt(4 * nodeRadius * nodeRadius)\\\"},\\n              \\\"iterations\\\": 1,\\n              \\\"strength\\\": 0.6\\n            },\\n            {\\n              \\\"force\\\": \\\"nbody\\\",\\n              \\\"strength\\\": {\\n                \\\"signal\\\": \\\"nodeCharge\\\"\\n              },\\n              \\\"distanceMin\\\": 1,\\n              \\\"distanceMax\\\": 300\\n            },\\n            {\\n              \\\"force\\\": \\\"link\\\",\\n              \\\"links\\\": \\\"link-data\\\",\\n              \\\"distance\\\": {\\n                \\\"signal\\\": \\\"linkDistance\\\"\\n              },\\n              \\\"id\\\": \\\"segment\\\",\\n              \\\"strength\\\": .4\\n            }\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"fx\\\",\\n          \\\"expr\\\": \\\"fix[0]!=null && node==datum.index ?invert('xscale',fix[0]):null\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"fy\\\",\\n          \\\"expr\\\": \\\"fix[1]!=null && node==datum.index ?invert('yscale',fix[1]):null\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"link-data2\\\",\\n      \\\"source\\\": \\\"link-data\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"linkpath\\\",\\n          \\\"require\\\": {\\n            \\\"signal\\\": \\\"force\\\"\\n          },\\n          \\\"shape\\\": \\\"line\\\",\\n          \\\"sourceX\\\": {\\n            \\\"expr\\\": \\\"scale('xscale', datum.source.x)\\\"\\n          },\\n          \\\"sourceY\\\": {\\n            \\\"expr\\\": \\\"scale('yscale', datum.source.y)\\\"\\n          },\\n          \\\"targetX\\\": {\\n            \\\"expr\\\": \\\"scale('xscale', datum.target.x)\\\"\\n          },\\n          \\\"targetY\\\": {\\n            \\\"expr\\\": \\\"scale('yscale', datum.target.y)\\\"\\n          }\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"atan2(datum.target.y - datum.source.y,datum.source.x - datum.target.x)\\\",\\n          \\\"as\\\": \\\"angle1\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(datum.angle1>=0?datum.angle1:(2*PI + datum.angle1)) * (360 / (2*PI))\\\",\\n          \\\"as\\\": \\\"angle2\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(360-datum.angle2)*(PI/180)\\\",\\n          \\\"as\\\": \\\"angle3\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(cos(datum.angle3)*(nodeRadius+5))+(scale('xscale',datum.target.x))\\\",\\n          \\\"as\\\": \\\"arrowX\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(sin(datum.angle3)*(nodeRadius+5))+(scale('yscale',datum.target.y))\\\",\\n          \\\"as\\\": \\\"arrowY\\\"\\n        }, \\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\" (length(datum.source.sources) == 1 && length(datum.source.targets)==1) && datum.source.sources[0] == datum.source.targets[0] ? true : false \\\",\\n          \\\"as\\\": \\\"bidirectional\\\"\\n        }\\n      ]\\n    }\\n  ],\\n  \\\"scales\\\": [\\n    {\\n      \\\"name\\\": \\\"color\\\",\\n      \\\"type\\\": \\\"ordinal\\\",\\n      \\\"domain\\\": {\\n        \\\"data\\\": \\\"node-data\\\",\\n        \\\"field\\\": \\\"group\\\"\\n      },\\n      \\\"range\\\": [\\n        \\\"#4682b4\\\",\\n        \\\"#4666b4\\\",\\n        \\\"#46b494\\\",\\n        \\\"#b46746\\\",\\n        \\\"#b44662\\\",\\n        \\\"#a44fa3\\\"\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"xscale\\\",\\n      \\\"zero\\\": false,\\n      \\\"domain\\\": {\\n        \\\"signal\\\": \\\"xdom\\\"\\n      },\\n      \\\"range\\\": {\\n        \\\"signal\\\": \\\"xrange\\\"\\n      }\\n    },\\n    {\\n      \\\"name\\\": \\\"yscale\\\",\\n      \\\"zero\\\": false,\\n      \\\"domain\\\": {\\n        \\\"signal\\\": \\\"ydom\\\"\\n      },\\n      \\\"range\\\": {\\n        \\\"signal\\\": \\\"yrange\\\"\\n      }\\n    }\\n  ],\\n  \\\"marks\\\": [\\n    {\\n      \\\"type\\\": \\\"path\\\",\\n      \\\"name\\\": \\\"links\\\",\\n      \\\"zindex\\\": 1,\\n      \\\"from\\\": {\\n        \\\"data\\\": \\\"link-data2\\\"\\n      },\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"path\\\": {\\\"field\\\": \\\"path\\\"},\\n          \\\"stroke\\\": {\\n            \\\"signal\\\": \\\"(datum.source.index!=nodeHover.id && datum.target.index!=nodeHover.id) ? '#EDBB9A':merge(hsl(scale('color', datum.source.group)), {l:0.64})\\\"\\n          },\\n          \\\"strokeWidth\\\": {\\n            \\\"signal\\\": \\\"datum.source.index!=nodeHover.id && datum.target.index!=nodeHover.id ? 3:5\\\"\\n          }\\n        },\\n     \\n      \\\"hover\\\": {\\n          \\\"cursor\\\": {\\\"value\\\":\\\"pointer\\\"},\\n          \\\"tooltip\\\": {\\n            \\\"signal\\\": \\\"datum.bidirectional == true ? {'direction': 'bi-directional', 'connection': datum.key.src+' ↔ ' +datum.key.dst} : {'direction':'uni-directional', 'connection': datum.key.src+' → ' +datum.key.dst}\\\"\\n            \\\"color\\\": \\\"pink\\\"\\n          }\\n        }\\n       },\\n      \\n    },/*\\n    {\\n      \\\"type\\\": \\\"symbol\\\",\\n      \\\"name\\\": \\\"arrows\\\",\\n      \\\"zindex\\\": 1,\\n      \\\"from\\\": {\\n        \\\"data\\\": \\\"link-data2\\\"\\n      },\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"shape\\\": {\\n            \\\"value\\\": \\\"triangle\\\"\\n          },\\n          \\\"angle\\\": {\\n            \\\"signal\\\": \\\"-datum.angle2-90\\\"\\n          },\\n          \\\"x\\\": {\\n            \\\"signal\\\": \\\"datum.arrowX\\\"\\n          },\\n          \\\"y\\\": {\\n            \\\"signal\\\": \\\"datum.arrowY\\\"\\n          },\\n          \\\"text\\\": {\\n            \\\"signal\\\": \\\"'▲'\\\"\\n          },\\n          \\\"fill\\\": {\\n            \\\"signal\\\": \\\"datum.source.index!=nodeHover.id && datum.target.index!=nodeHover.id ? '#929399':merge(hsl(scale('color', datum.source.group)), {l:0.64})\\\"\\n          },\\n          \\\"size\\\": {\\n            \\\"signal\\\": \\\"nodeRadius==1?0:60\\\"\\n          }\\n        },\\n        \\\"hover\\\": {\\n          \\\"tooltip\\\": {\\n            \\\"signal\\\": \\\"datum\\\"\\n          }\\n          \\n        }\\n      }\\n    },*/\\n\\n    {\\n      \\\"name\\\": \\\"nodes\\\",\\n      \\\"type\\\": \\\"symbol\\\",\\n      \\\"zindex\\\": 1,\\n      \\\"from\\\": {\\n        \\\"data\\\": \\\"node-data\\\"\\n      },\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"opacity\\\": {\\n            \\\"value\\\": 1\\n          }\\n          \\\"fill\\\": {\\n            \\\"signal\\\": \\\"nodeHover.id===datum.index || indexof(nodeHover.connections, datum.segment)>-1 ?scale('color', datum.group):merge(hsl(scale('color', datum.group)), {l:0.64})\\\"\\n          },\\n          \\\"stroke\\\": {\\n            \\\"signal\\\": \\\"nodeHover.id===datum.index || indexof(nodeHover.connections, datum.segment)>-1 ?scale('color', datum.group):merge(hsl(scale('color', datum.group)), {l:0.84})\\\"\\n          },\\n          \\\"strokeWidth\\\": {\\n            \\\"value\\\": 3\\n          },\\n          \\\"strokeOpacity\\\": {\\n            \\\"value\\\": 1\\n          },\\n          \\\"size\\\": {\\n            \\\"signal\\\": \\\"4 * nodeRadius * nodeRadius\\\"\\n          },\\n          \\\"cursor\\\": {\\n            \\\"value\\\": \\\"pointer\\\"\\n          },\\n          \\\"x\\\": {\\n            \\\"signal\\\": \\\"fix[0]!=null && node===datum.index ?fix[0]:scale('xscale', datum.x)\\\"\\n          },\\n          \\\"y\\\": {\\n            \\\"signal\\\": \\\"fix[1]!=null && node===datum.index ?fix[1]:scale('yscale', datum.y)\\\"\\n          }\\n        },\\n        \\\"hover\\\": {\\n          \\\"tooltip\\\": {\\n            \\\"signal\\\": \\\"{'Segment': datum.segment, 'Type': datum.group, 'Connections': datum.doc_count}\\\"\\n          }\\n        }\\n      },\\n      \\n    }/*,\\n    {\\n      \\\"type\\\": \\\"text\\\",\\n      \\\"name\\\": \\\"labels\\\",\\n      \\\"from\\\": {\\n        \\\"data\\\": \\\"nodes\\\"\\n      },\\n      \\\"zindex\\\": 2,\\n      \\\"interactive\\\": false,\\n      \\\"enter\\\": {},\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"fill\\\": {\\n            \\\"signal\\\": \\\"'white'\\\"\\n          },\\n          \\\"y\\\": {\\n            \\\"field\\\": \\\"y\\\"\\n          },\\n          \\\"x\\\": {\\n            \\\"field\\\": \\\"x\\\"\\n          },\\n          \\\"text\\\": {\\n            \\\"field\\\": \\\"datum.group\\\"\\n          },\\n          \\\"align\\\": {\\n            \\\"value\\\": \\\"center\\\"\\n          },\\n          \\\"fontSize\\\": {\\n            \\\"value\\\": 10\\n          },\\n          \\\"baseline\\\": {\\n            \\\"value\\\": \\\"middle\\\"\\n          },\\n          \\\"limit\\\": {\\n            \\\"signal\\\": \\\"clamp(sqrt(4 * nodeRadius * nodeRadius)-7,1,1000)\\\"\\n          },\\n          \\\"ellipsis\\\": {\\n            \\\"value\\\": \\\" \\\"\\n          }\\n        }\\n      }\\n    }\\n    */\\n ] \\n}\"}}"
      },
      "id": "32c684e0-be65-11ef-9ff5-ff2a2927176e",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-10-20T19:16:08.928Z",
      "version": "WzE1NTQsMV0="
    },
    {
      "attributes": {
        "description": "",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":\"source.segment.id:* OR destination.segment.id:*\",\"language\":\"lucene\"},\"filter\":[]}"
        },
        "savedSearchRefName": "search_0",
        "title": "VADR - Traffic by Network Segment",
        "uiStateJSON": "{\"vis\":{\"params\":{\"sort\":{\"columnIndex\":6,\"direction\":\"desc\"}},\"sortColumn\":{\"colIndex\":6,\"direction\":\"desc\"}}}",
        "version": 1,
        "visState": "{\"title\":\"VADR - Traffic by Network Segment\",\"type\":\"table\",\"aggs\":[{\"id\":\"1\",\"enabled\":true,\"type\":\"count\",\"params\":{\"customLabel\":\"Log Count\"},\"schema\":\"metric\"},{\"id\":\"4\",\"enabled\":true,\"type\":\"terms\",\"params\":{\"field\":\"related.site\",\"orderBy\":\"1\",\"order\":\"desc\",\"size\":100,\"otherBucket\":true,\"otherBucketLabel\":\"Other\",\"missingBucket\":true,\"missingBucketLabel\":\"-\",\"customLabel\":\"Site\"},\"schema\":\"bucket\"},{\"id\":\"6\",\"enabled\":true,\"type\":\"terms\",\"params\":{\"field\":\"network.direction\",\"orderBy\":\"1\",\"order\":\"desc\",\"size\":100,\"otherBucket\":true,\"otherBucketLabel\":\"Other\",\"missingBucket\":true,\"missingBucketLabel\":\"unknown\",\"customLabel\":\"Direction\"},\"schema\":\"bucket\"},{\"id\":\"3\",\"enabled\":true,\"type\":\"terms\",\"params\":{\"field\":\"source.segment.name\",\"orderBy\":\"1\",\"order\":\"desc\",\"size\":100,\"otherBucket\":true,\"otherBucketLabel\":\"Other\",\"missingBucket\":true,\"missingBucketLabel\":\"-\",\"customLabel\":\"Source Segment\"},\"schema\":\"bucket\"},{\"id\":\"5\",\"enabled\":true,\"type\":\"terms\",\"params\":{\"field\":\"destination.segment.name\",\"orderBy\":\"1\",\"order\":\"desc\",\"size\":100,\"otherBucket\":true,\"otherBucketLabel\":\"Other\",\"missingBucket\":true,\"missingBucketLabel\":\"SSDP, Broadcast, Multicast, etc.\",\"customLabel\":\"Destination Segment\"},\"schema\":\"bucket\"},{\"id\":\"7\",\"enabled\":true,\"type\":\"sum\",\"params\":{\"field\":\"network.packets\",\"customLabel\":\"Total Packets\"},\"schema\":\"metric\"},{\"id\":\"8\",\"enabled\":true,\"type\":\"sum\",\"params\":{\"field\":\"network.bytes\",\"customLabel\":\"Total Bytes\"},\"schema\":\"metric\"}],\"params\":{\"perPage\":30,\"showPartialRows\":false,\"showMetricsAtAllLevels\":false,\"sort\":{\"columnIndex\":null,\"direction\":null},\"showTotal\":false,\"totalFunc\":\"sum\",\"percentageCol\":\"\"}}"
      },
      "id": "02ef18f0-bd97-11ef-b43b-112c1ca27e0b",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [
        {
          "id": "b1645e70-8182-11ed-8ccb-af218b39580f",
          "name": "search_0",
          "type": "search"
        }
      ],
      "type": "visualization",
      "updated_at": "2025-10-20T19:16:08.928Z",
      "version": "WzE1MzAsMV0="
    },
    {
      "attributes": {
        "description": "",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":\"\",\"language\":\"kuery\"},\"filter\":[]}"
        },
        "title": "VADR - Arkime Force Directed",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"VADR - Arkime Force Directed\",\"type\":\"markdown\",\"aggs\":[],\"params\":{\"fontSize\":12,\"openLinksInNewTab\":false,\"markdown\":\"[Arkime Segment Force Directed](/arkime/connections?srcField=source.segment.name&dstField=destination.segment.name&date=4380&length=5000)  \"}}"
      },
      "id": "a57e8860-3116-11f0-af4f-052f357bea07",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-10-20T19:16:08.928Z",
      "version": "WzE2MDEsMV0="
    },
    {
      "attributes": {
        "description": "",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":\"   event.dataset:(dns OR conn) AND NOT source.ip:169.254.0.0/16  AND NOT destination.ip:(224.0.0.0/16 OR 255.0.0.0/8 OR 239.0.0.0/8) AND NOT network.type:\\\"ipv6\\\"\",\"language\":\"kuery\"},\"filter\":[]}"
        },
        "title": "VADR - Force Directed IPs",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"VADR - Force Directed IPs\",\"type\":\"vega\",\"aggs\":[],\"params\":{\"spec\":\"## Force-Directed Graph for Network Analysis\\n## Purpose: To showcase connections between ipv4 addresses within a time period and highlight different roles as assigned by each IP\\n## Author: Mackenzie Zappe \\n## Last updated: 6/18/2025\\n\\n## Main feature update in this version: \\n##  - Variably-sized nodes based on number of connections, number of connections was normalized then applied to a linear scale\\n##  -- Implemented as a toggle while bug is being worked on\\n##  - Removed nodeRadiusKey signal (key-based input changes size of node radius) \\n##  - Populated Tag in node tooltip with first known tag (if it exists) \\n##  - Dynamic node color scale domain implemented & dynamic roles populated \\n\\n##  BUGS: \\n##  - NodeSize is weird for some instances - scale value might be a factor with this \\n\\n{\\n##  Set up Vega specification definitions\\n##  Pay attention to Vega additions after V5 \\n  \\\"$schema\\\": \\\"https://vega.github.io/schema/vega/v5.json\\\",\\n  \\\"description\\\": \\\"Force-Directed Network Graph with data from Malcolm\\\",\\n  \\\"autosize\\\": \\\"fit\\\",\\n  \\\"background\\\": \\\"#5F8080\\\",\\n##  --------------------------------------------------------------------------------------------------------------------------\\n##  SECTION 0: Config --------------------------------------------------------------------------------------------------------\\n##  Define Specification constants like multiple legend positioning\\n##  - arguments set in Config WILL be overwritten if redefined later in specification\\n  \\\"config\\\":{\\n      \\\"legend\\\": {\\n        \\\"layout\\\": {\\n      ##  Applies the following layout arguments to legends that have the \\\"orient\\\": \\\"top-right\\\" \\n          \\\"top-right\\\": {\\n            \\\"anchor\\\": \\\"middle\\\",\\n            \\\"direction\\\": \\\"vertical\\\",\\n            \\\"center\\\": true,\\n            \\\"margin\\\": 10,\\n          }\\n        }\\n      }\\n  },\\n##  ---------------------------------------------------------------------------------------------------------------------------\\n##  SECTION 1: Signals --------------------------------------------------------------------------------------------------------\\n##  - Define dynamic variables (Signals) that can be updated at any point during the specification\\n  \\\"signals\\\": [\\n    {\\n    ##  Sets the domain space for the visualization - will change if window size is adjusted \\n      \\\"name\\\": \\\"xrange\\\",\\n      \\\"update\\\": \\\"[0, width]\\\" ## width is automatically defined based on autosize \\n    },\\n    {\\n    ##  Sets the range space for the visualization - will change if window size is adjusted \\n      \\\"name\\\": \\\"yrange\\\",\\n      \\\"update\\\": \\\"[height, 0]\\\" ## height is automatically defined based on autosize\\n    },\\n    {\\n    ## Updated by xdom signal \\n      \\\"name\\\": \\\"xext\\\",\\n      \\\"update\\\": \\\"[0, width]\\\"\\n    },\\n    {\\n    ##  Updated by ydom signal\\n      \\\"name\\\": \\\"yext\\\",\\n      \\\"update\\\": \\\"[height, 0]\\\"\\n    },\\n    {\\n    ##  Default filter to only display ipv4 connection behavior\\n      \\\"name\\\": \\\"networkType\\\",\\n      \\\"value\\\": null,\\n      \\\"update\\\": \\\"opensearchDashboardsAddFilter({\\\\\\\"match_phrase\\\\\\\": { \\\\\\\"network.type\\\\\\\": 'ipv4' } }, 'MALCOLM_NETWORK_INDEX_PATTERN_REPLACER')\\\"\\n    },\\n    {\\n    ## Filter to related ip on User double click of node\\n      \\\"name\\\": \\\"click\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:dblclick!\\\",\\n          \\\"update\\\": \\\"opensearchDashboardsAddFilter({\\\\\\\"match_phrase\\\\\\\": { \\\\\\\"related.ip\\\\\\\": datum.ip } }, 'MALCOLM_NETWORK_INDEX_PATTERN_REPLACER')\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"down\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mouseup,touchend\\\",\\n          \\\"update\\\": \\\"null\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart\\\",\\n          \\\"update\\\": \\\"xy()\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"symbol:mousedown, symbol:touchstart\\\",\\n          \\\"update\\\": \\\"null\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"xcur\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart, touchend\\\",\\n          \\\"update\\\": \\\"xdom\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"ycur\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart, touchend\\\",\\n          \\\"update\\\": \\\"ydom\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"delta\\\",\\n      \\\"value\\\": [0, 0],\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"window\\\",\\n              \\\"type\\\": \\\"mousemove\\\",\\n              \\\"consume\\\": true,\\n              \\\"between\\\": [\\n                {\\n                  \\\"type\\\": \\\"mousedown\\\"\\n                },\\n                {\\n                  \\\"source\\\": \\\"window\\\",\\n                  \\\"type\\\": \\\"mouseup\\\"\\n                }\\n              ]\\n            },\\n            {\\n              \\\"type\\\": \\\"touchmove\\\",\\n              \\\"consume\\\": true,\\n              \\\"filter\\\": \\\"event.touches.length === 1\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"down ? [down[0]-x(), y()-down[1]] : [0,0]\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"anchor\\\",\\n      \\\"value\\\": [0, 0],\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"wheel\\\",\\n          \\\"update\\\": \\\"[invert('xscale', x()), invert('yscale', y())]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchstart\\\",\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"[(xdom[0] + xdom[1]) / 2, (ydom[0] + ydom[1]) / 2]\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"zoom\\\",\\n      \\\"value\\\": 1,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"wheel!\\\",\\n          \\\"force\\\": true,\\n          \\\"update\\\": \\\"pow(1.001, event.deltaY * pow(16, event.deltaMode))\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"dist2\\\"\\n          },\\n          \\\"force\\\": true,\\n          \\\"update\\\": \\\"dist1 / dist2\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"1\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"dist1\\\",\\n      \\\"value\\\": 0,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchstart\\\",\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"pinchDistance(event)\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"dist2\\\"\\n          },\\n          \\\"update\\\": \\\"dist2\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"dist2\\\",\\n      \\\"value\\\": 0,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchmove\\\",\\n            \\\"consume\\\": true,\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"pinchDistance(event)\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"xdom\\\",\\n      \\\"update\\\": \\\"xext\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"delta\\\"\\n          },\\n          \\\"update\\\": \\\"[xcur[0] + span(xcur) * delta[0] / width, xcur[1] + span(xcur) * delta[0] / width]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"zoom\\\"\\n          },\\n          \\\"update\\\": \\\"[anchor[0] + (xdom[0] - anchor[0]) * zoom, anchor[0] + (xdom[1] - anchor[0]) * zoom]\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"xrange\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"ydom\\\",\\n      \\\"update\\\": \\\"yext\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"delta\\\"\\n          },\\n          \\\"update\\\": \\\"[ycur[0] + span(ycur) * delta[1] / height, ycur[1] + span(ycur) * delta[1] / height]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"zoom\\\"\\n          },\\n          \\\"update\\\": \\\"[anchor[1] + (ydom[0] - anchor[1]) * zoom, anchor[1] + (ydom[1] - anchor[1]) * zoom]\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"yrange\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"size\\\",\\n      \\\"update\\\": \\\"clamp(20 / span(xdom), 1, 1000)\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"cx\\\",\\n      \\\"update\\\": \\\"width / 2\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"[symbol:mousedown, window:mouseup] > window:mousemove\\\",\\n          \\\"update\\\": \\\"cx==width/2?cx+0.001:width/2\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"cy\\\",\\n      \\\"update\\\": \\\"height / 2\\\"\\n    },\\n    {\\n    ##  Static setting of nodeRadius - does not actually impact visual radius of nodes \\n    ##  - Used for nbody charge calculations and arrow positioning calculations \\n      \\\"name\\\": \\\"nodeRadius\\\",\\n      \\\"value\\\": 15,\\n      /* \\n      ##  Gets user input from slider to determine nodeRadius. \\n      ##  - Commented out 6/18 because feature is not needed at this time [MZ] \\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"range\\\",\\n        \\\"min\\\": 1,\\n        \\\"max\\\": 50,\\n        \\\"step\\\": 1\\n      },\\n      */\\n    },\\n    {\\n      \\\"name\\\": \\\"dynamicRadius\\\",\\n      \\\"value\\\": false,\\n      \\\"bind\\\":{\\n        \\\"input\\\": \\\"radio\\\",\\n        \\\"options\\\": [true,false]\\n      }\\n    },\\n    {\\n    ##  Sets collide force value \\n      \\\"name\\\": \\\"nodeCharge\\\",\\n      \\\"value\\\":-50,\\n      /* \\n      ##  Gets user input from slider to determine nodeCharge. \\n      ##  - Commented out 6/18 because feature is not needed at this time [MZ] \\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"range\\\",\\n        \\\"min\\\": -100,\\n        \\\"max\\\": 10,\\n        \\\"step\\\": 1\\n      }\\n      */\\n    },\\n    {\\n    ## Sets static distance between nodes\\n    ##  - Used for links force calculation \\n    ##  NOTE: (future idea) Dynamically define linkDistance as a function of doc_count to represent varying clustering capability (longer link == less connections, shorter link == more connections and higher clustering )   \\n      \\\"name\\\": \\\"linkDistance\\\",\\n      \\\"value\\\": 80,\\n    },\\n    {\\n    ##  Determines whether a node is being hovered over and \\n    ##  - Used for positioning nodes \\n      \\\"description\\\": \\\"State variable for active node fix status.\\\",\\n      \\\"name\\\": \\\"fix\\\",\\n      \\\"value\\\": false,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:mouseout[!event.buttons], window:mouseup\\\",\\n          \\\"update\\\": \\\"false\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"symbol:mouseover\\\",\\n          \\\"update\\\": \\\"fix || true\\\",\\n          \\\"force\\\": true\\n        },\\n        {\\n          \\\"events\\\": \\\"[symbol:mousedown, window:mouseup] > window:mousemove!\\\",\\n          \\\"update\\\": \\\"xy()\\\",\\n          \\\"force\\\": true\\n        }\\n      ]\\n    },\\n    {\\n    ##  Gets datum index value based on which node is being hovered over \\n    ##  - Used for positioning nodes\\n      \\\"description\\\": \\\"Graph node most recently interacted with.\\\",\\n      \\\"name\\\": \\\"node\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:mouseover\\\",\\n          \\\"update\\\": \\\"fix === true ? datum.index : node\\\"\\n        }\\n      ]\\n    },\\n    {\\n    ##  Gets node-specific information about node being hovered over by user \\n    ##  - Used for node tooltip  \\n      \\\"name\\\": \\\"nodeHover\\\",\\n      \\\"value\\\": {\\n        \\\"id\\\": null,\\n        \\\"connections\\\": []\\n      },\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"symbol:mouseover\\\",\\n          \\\"update\\\": \\\"{'id':datum.index, 'connections':split(datum.sources+','+datum.targets,',')}\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"symbol:mouseout\\\",\\n          \\\"update\\\": \\\"{'id':null, 'connections':[]}\\\"\\n        }\\n      ]\\n    },\\n    {\\n    ##  Double clicking in blank space resets graph to nodes clustering around the middle \\n      \\\"description\\\": \\\"Flag to restart Force simulation upon data changes.\\\",\\n      \\\"name\\\": \\\"restart\\\",\\n      \\\"value\\\": false,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"fix\\\"\\n          },\\n          \\\"update\\\": \\\"fix && fix.length\\\"\\n        }\\n      ]\\n    },\\n  ],\\n## --------------------------------------------------------------------------------------------------------------------------\\n##  SECTION 2: DATA --------------------------------------------------------------------------------------------------------\\n##  Define datasets and data normalization to be worked with in schema \\n  \\\"data\\\": [\\n    {\\n      \\\"name\\\": \\\"raw-data\\\",\\n      \\\"url\\\": {\\n        \\\"%context%\\\": true,\\n        \\\"%timefield%\\\": \\\"MALCOLM_NETWORK_INDEX_TIME_FIELD_REPLACER\\\",\\n        \\\"index\\\": \\\"MALCOLM_NETWORK_INDEX_PATTERN_REPLACER\\\",\\n        \\\"body\\\": {\\n          \\\"size\\\": 0,\\n          \\\"aggs\\\": {\\n          ##  Define parameters for \\n            \\\"connections\\\": {\\n              \\\"composite\\\": {\\n                \\\"size\\\": 1000,\\n                \\\"sources\\\": [\\n                  {\\n                    \\\"src\\\": {\\n                      \\\"terms\\\": {\\\"field\\\": \\\"source.ip\\\" }\\n                    }\\n                  },\\n                  {\\n                    \\\"dst\\\": {\\n                      \\\"terms\\\": {\\\"field\\\": \\\"destination.ip\\\"}\\n                    }\\n                  }\\n                ]\\n              },\\n              \\\"aggs\\\": {\\n              ##  Determine what fields to pull from arkime_sessions  \\n                \\\"top_tags\\\": {\\n                  \\\"top_hits\\\": {\\n                    \\\"size\\\": 1,\\n                    \\\"_source\\\": {\\n                      \\\"includes\\\": [\\n                        \\\"tags\\\",\\n                        \\\"source\\\",\\n                        \\\"destination\\\",\\n                        \\\"source.ip\\\",\\n                        \\\"destination.ip\\\"\\n                      ]\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      },\\n      \\\"format\\\": {\\n      ##  Group arkime_data relative to its connections \\n        \\\"property\\\": \\\"aggregations.connections.buckets\\\"\\n      }\\n    },\\n    {\\n    ## Transform raw-data into source/target link definitions \\n      \\\"name\\\": \\\"link-data-raw\\\",\\n      \\\"source\\\": \\\"raw-data\\\",\\n      \\\"transform\\\": [\\n      ##  OPTIMIZE: Check if doc_count and tags are actually needed as part of this dataset\\n        {\\n        ##  Renames key.src from raw-data to source\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"source\\\",\\n          \\\"expr\\\": \\\"datum.key.src\\\"\\n        },\\n        {\\n        ##  Renames key.dst from raw-data to target\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"target\\\",\\n          \\\"expr\\\": \\\"datum.key.dst\\\"\\n        },\\n        {\\n        ##  Renames doc_count from raw-data to value\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"value\\\",\\n          \\\"expr\\\": \\\"datum.doc_count\\\"\\n        },\\n        {\\n        ##  Renames tags from raw-data to tags\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"tags\\\",\\n          \\\"expr\\\": \\\"datum.top_tags.hits.hits[0]._source.tags\\\"\\n        },\\n        {\\n        ##  Assigns each newly created link between source/target a unique identifier starting at 1 \\n          \\\"type\\\": \\\"window\\\",\\n          \\\"ops\\\": [\\n            \\\"row_number\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"index\\\"\\n          ]\\n        }\\n      ]\\n    },\\n    {\\n    ##  Exact replica of link-data-raw\\n    ##  NOTE: For some reason, when a dataset is used to make a linkpath that dataset is set to null when linkpat transform is complete. Additional features required use of link-data-raw so duplication was the solution [MZ]\\n      \\\"name\\\": \\\"link-data\\\",\\n      \\\"source\\\": \\\"link-data-raw\\\"\\n    },\\n    \\n    {\\n      \\\"name\\\": \\\"source-connections\\\",\\n      \\\"source\\\": \\\"link-data-raw\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"source\\\"\\n          ],\\n          \\\"ops\\\": [\\n            \\\"values\\\"\\n          ],\\n          \\\"fields\\\": [\\n            \\\"target\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"connections\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"targets\\\",\\n          \\\"expr\\\": \\\"pluck(datum.connections, 'target')\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"target-connections\\\",\\n      \\\"source\\\": \\\"link-data-raw\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"target\\\"\\n          ],\\n          \\\"ops\\\": [\\n            \\\"values\\\"\\n          ],\\n          \\\"fields\\\": [\\n            \\\"source\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"connections\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"sources\\\",\\n          \\\"expr\\\": \\\"pluck(datum.connections, 'source')\\\"\\n        }\\n      ]\\n    },\\n    {\\n    ##  Creates device lookup dataset for sources\\n      \\\"name\\\": \\\"node-src-device-data\\\",\\n      \\\"source\\\": \\\"raw-data\\\",\\n      \\\"transform\\\": [\\n        {\\n        ##  Collects source device info from raw-data to store in device_src\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"device_src\\\",\\n          \\\"expr\\\": \\\"datum.top_tags.hits.hits[0]._source.source\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"ip_address\\\",\\n          \\\"expr\\\": \\\"datum.device_src.ip\\\"\\n        }\\n      ]\\n    },\\n    {\\n    ##  Creates device lookup dataset for destinations\\n      \\\"name\\\": \\\"node-dst-device-data\\\",\\n      \\\"source\\\": \\\"raw-data\\\",\\n      \\\"transform\\\": [\\n        {\\n        ##  Collects destination device info from raw-data to store in device_dst\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"device_dst\\\",\\n          \\\"expr\\\": \\\"datum.top_tags.hits.hits[0]._source.destination\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"ip_address\\\",\\n          \\\"expr\\\": \\\"datum.device_dst.ip\\\"\\n        }\\n      ]\\n    },\\n    {\\n    ##  Defines dataset that creates the individual node objects & remove duplicates \\n      \\\"name\\\": \\\"node-data-raw\\\",\\n      \\\"source\\\": \\\"raw-data\\\",\\n      \\\"transform\\\": [\\n        {\\n        ##  Renames key.src from raw-data to source\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"source\\\",\\n          \\\"expr\\\": \\\"datum.key.src\\\"\\n        },\\n        {\\n        ##  Renames key.dst from raw-data to target\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"target\\\",\\n          \\\"expr\\\": \\\"datum.key.dst\\\"\\n        },\\n        {\\n        ##  Renames doc_count from raw-data to value\\n        ##  XXX: doc_count has a lot of transformation in this dataset, keep an eye on its value as it transforms \\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"value\\\",\\n          \\\"expr\\\": \\\"datum.doc_count\\\"\\n        },\\n        {\\n        ##  Grabs specific tag array from raw-data to tags\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"tags\\\",\\n          \\\"expr\\\": \\\"datum.top_tags.hits.hits[0]._source.tags\\\"\\n        },\\n        {\\n        ##  Create 'dict'-like item to map source/target connections \\n          \\\"type\\\": \\\"fold\\\",\\n          \\\"fields\\\": [\\n            \\\"source\\\",\\n            \\\"target\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"key\\\",\\n            \\\"ip\\\"\\n          ]\\n        },\\n        {\\n        ##  Collect sum of connections based on target ip address \\n        ##  - Every node is a destination/target but not every node is a source \\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"ip\\\"\\n          ],\\n          \\\"ops\\\": [\\n            \\\"sum\\\",\\n          ],\\n          \\\"fields\\\": [\\n            \\\"value\\\",\\n          ],\\n          \\\"as\\\": [\\n            \\\"doc_count\\\",\\n          ]\\n        },\\n        {\\n        ##  Lookup tag values for the target node from the raw-data set\\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"raw-data\\\",\\n          \\\"key\\\": \\\"key.dst\\\",\\n          \\\"fields\\\": [\\n            \\\"ip\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"top_tags.hits.hits[0]._source.tags\\\",\\n          ],\\n          \\\"as\\\": [\\n            \\\"tags\\\",\\n          ],\\n          \\\"default\\\": [\\n            null\\n          ]\\n        },\\n        {\\n        ##  Assign group field as a 1st value of tags array - if it exists\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"group\\\",\\n          \\\"expr\\\": \\\"length(datum.tags) && datum.tags[0] ? datum.tags[0] : 'No Tag'\\\"\\n        },\\n        {\\n        ##  For source node, determine if the device data exists \\n        ##  NOTE: This is important because the device data sometimes only stored in the source OR destination field of raw-data (depending on connection context) \\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"node-src-device-data\\\",\\n          \\\"key\\\": \\\"key.src\\\",\\n          \\\"fields\\\": [\\n            \\\"ip\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"device_src\\\",\\n          ],\\n          \\\"as\\\": [\\n            \\\"device1\\\",\\n          ],\\n          \\\"default\\\": [\\n            null\\n          ]\\n        },\\n        {\\n        ##  For target node, determine if the device data exists \\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"node-dst-device-data\\\",\\n          \\\"key\\\": \\\"key.dst\\\",\\n          \\\"fields\\\": [\\n            \\\"ip\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"device_dst\\\",\\n          ],\\n          \\\"as\\\": [\\n            \\\"device2\\\",\\n          ],\\n          \\\"default\\\": [\\n            null\\n          ]\\n        },\\n        {\\n        ##  Assigns each newly created node a unique identifier starting at 1 \\n          \\\"type\\\": \\\"window\\\",\\n          \\\"ops\\\": [\\n            \\\"row_number\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"index\\\"\\n          ]\\n        }\\n      ]\\n    },\\n    {\\n    ##  Defines dataset that is used to define node-to-node behavior\\n      \\\"name\\\": \\\"node-data\\\",\\n      \\\"source\\\": \\\"node-data-raw\\\",\\n      \\\"transform\\\": [\\n        {\\n        ##  Define source based on which targets it reaches out to\\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"source-connections\\\",\\n          \\\"key\\\": \\\"source\\\",\\n          \\\"fields\\\": [\\n            \\\"ip\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"targets\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"targets\\\"\\n          ],\\n          \\\"default\\\": [\\n            \\\"\\\"\\n          ]\\n        },\\n        {\\n        ##  Define target based on which sources reach out to it \\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"target-connections\\\",\\n          \\\"key\\\": \\\"target\\\",\\n          \\\"fields\\\": [\\n            \\\"ip\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"sources\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"sources\\\"\\n          ],\\n          \\\"default\\\": [\\n            \\\"\\\"\\n          ]\\n        },\\n        {\\n        ##  Apply series of forces to determine where on the screen the nodes will sit in relation to each other \\n          \\\"type\\\": \\\"force\\\",\\n          \\\"iterations\\\": 600,\\n          \\\"restart\\\": {\\n            \\\"signal\\\": \\\"restart\\\"\\n          },\\n          \\\"velocityDecay\\\": 0.7,\\n          \\\"signal\\\": \\\"force\\\",\\n          \\\"forces\\\": [\\n            {\\n              \\\"force\\\": \\\"center\\\",\\n              \\\"x\\\": {\\n                \\\"signal\\\": \\\"cx\\\"\\n              },\\n              \\\"y\\\": {\\n                \\\"signal\\\": \\\"cy\\\"\\n              }\\n            },\\n            {\\n              \\\"force\\\": \\\"x\\\",\\n              \\\"x\\\": {\\n                \\\"expr\\\": \\\"width/2\\\"\\n              },\\n              \\\"strength\\\": 0.0015\\n            },\\n            {\\n              \\\"force\\\": \\\"y\\\",\\n              \\\"y\\\": {\\n                \\\"expr\\\": \\\"height/2\\\"\\n              },\\n              \\\"strength\\\": 0.0015\\n            },\\n            {\\n              \\\"force\\\": \\\"collide\\\",\\n              \\\"radius\\\": {\\\"signal\\\": \\\"sqrt(4 * nodeRadius * nodeRadius)\\\"},\\n              \\\"iterations\\\": 1,\\n              \\\"strength\\\": 0.6\\n            },\\n            {\\n              \\\"force\\\": \\\"nbody\\\",\\n              \\\"strength\\\": {\\n                \\\"signal\\\": \\\"nodeCharge\\\"\\n              },\\n              \\\"distanceMin\\\": 1,\\n              \\\"distanceMax\\\": 300\\n            },\\n            {\\n              \\\"force\\\": \\\"link\\\",\\n              \\\"links\\\": \\\"link-data\\\",\\n              \\\"distance\\\": {\\\"expr\\\": \\\"linkDistance\\\"},\\n              \\\"id\\\": \\\"ip\\\",\\n              \\\"strength\\\": .2\\n            }\\n          ]\\n          \\n        },\\n        {\\n        ##  Calculate x position of node\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"fx\\\",\\n          \\\"expr\\\": \\\"fix[0]!=null && node==datum.index ?invert('xscale',fix[0]):null\\\"\\n        },\\n        {\\n        ##  Calculate y position of node\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"fy\\\",\\n          \\\"expr\\\": \\\"fix[1]!=null && node==datum.index ?invert('yscale',fix[1]):null\\\"\\n        },\\n        {\\n        ##  Calculate max and min connection counts\\n        ##  - Used to normalize for nodeSizing \\n          \\\"type\\\": \\\"extent\\\", \\n          \\\"field\\\": \\\"doc_count\\\",\\n          \\\"signal\\\": \\\"doc_max_min\\\",\\n        },\\n        {\\n        ##  Normalize Connection counts\\n        ##  - Used in nodeSizing\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(datum.doc_count - doc_max_min[0]) / (doc_max_min[1] - doc_max_min[0]) || .00001\\\",\\n          \\\"as\\\": \\\"doc_count_normal\\\"\\n        },\\n        {\\n        ##  Determine where the device info exists and allocate it as the device \\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"device\\\",\\n          \\\"expr\\\": \\\"(datum.device2.device ? datum.device2.device : (datum.device1.device ? datum.device1.device : 'null') )\\\"\\n        },\\n        {\\n        ##  Extract role value as a string \\n        ##  - Used in node tooltip\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"roles\\\",\\n          \\\"expr\\\": \\\"datum.device.role ? toString(datum.device.role) : 'unknown'\\\"\\n        },\\n        {\\n        ##  Extract manufacturer value as a string \\n        ##  - Used in node tooltip\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"manufacturer\\\",\\n          \\\"expr\\\": \\\"toString(datum.device.manufacturer)\\\"\\n        },\\n        {\\n        ##  Extract device name value as a string \\n        ##  - Used in node tooltip\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"as\\\": \\\"name\\\",\\n          \\\"expr\\\": \\\"toString(datum.device.name)\\\"\\n        },\\n        {\\n        ##  Determine node size based on normalized connection count number \\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"as\\\": \\\"size_node\\\",\\n          \\\"expr\\\": \\\"scale('nodeSize', datum.doc_count_normal * 10000)\\\",\\n        },\\n      ]\\n    },\\n    {\\n    ##  Defines linkpath data to connect nodes visually \\n      \\\"name\\\": \\\"link-data2\\\",\\n      \\\"source\\\": \\\"link-data\\\",\\n      \\\"transform\\\": [\\n        {\\n        ##  creates SVG paths between source (x,y) and target (x,y)\\n          \\\"type\\\": \\\"linkpath\\\",\\n          \\\"require\\\": {\\n            \\\"signal\\\": \\\"force\\\"\\n          },\\n          \\\"shape\\\": \\\"line\\\",\\n          \\\"sourceX\\\": {\\n            \\\"expr\\\": \\\"scale('xscale', datum.source.x)\\\"\\n          },\\n          \\\"sourceY\\\": {\\n            \\\"expr\\\": \\\"scale('yscale', datum.source.y)\\\"\\n          },\\n          \\\"targetX\\\": {\\n            \\\"expr\\\": \\\"scale('xscale', datum.target.x)\\\"\\n          },\\n          \\\"targetY\\\": {\\n            \\\"expr\\\": \\\"scale('yscale', datum.target.y)\\\"\\n          }\\n        },\\n        {\\n        ##  Determine bidirectionality of connections\\n        ##  - used in link tooltip\\n        ##  OPTIMIZE: Need to confirm that this is the most efficient way to do this \\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\" (length(datum.source.sources) == 1 && length(datum.source.targets)==1) && datum.source.sources[0] == datum.source.targets[0] ? true : false \\\",\\n          \\\"as\\\": \\\"bidirectional\\\"\\n        }\\n      ]\\n    }\\n  ],\\n## --------------------------------------------------------------------------------------------------------------------------\\n##  SECTION 3: Scales -------------------------------------------------------------------------------------------------------\\n##  Maps data values to either categorical data or numerical data to change the way the data presents visually \\n  \\\"scales\\\": [\\n    {\\n    ##  Determine color of node based on role\\n      \\\"name\\\": \\\"color\\\",\\n      \\\"type\\\": \\\"ordinal\\\",\\n      \\\"domain\\\": {\\\"data\\\": \\\"node-data\\\", \\\"field\\\": \\\"roles\\\"}\\n      ## HACK: Hardcoded domain values \\n      ## \\\"domain\\\":[\\\"HMI\\\", \\\"PLC\\\", \\\"SCADA\\\", \\\"Workstation\\\", \\\"Modem\\\", \\\"Server\\\", \\\"Historian\\\", \\\"unknown\\\", ],\\n      \\\"range\\\": [\\\"red\\\", \\\"orange\\\", \\\"yellow\\\", \\\"green\\\", \\\"blue\\\", \\\"purple\\\", \\\"black\\\"],\\n    },\\n    {\\n    ##  Sets x limits for where nodes can exists\\n      \\\"name\\\": \\\"xscale\\\",\\n      \\\"zero\\\": false,\\n      \\\"domain\\\": {\\n        \\\"signal\\\": \\\"xdom\\\"\\n      },\\n      \\\"range\\\": {\\n        \\\"signal\\\": \\\"xrange\\\"\\n      }\\n    },\\n    {\\n    ##  Sets y limits for where nodes can exists\\n      \\\"name\\\": \\\"yscale\\\",\\n      \\\"zero\\\": false,\\n      \\\"domain\\\": {\\n        \\\"signal\\\": \\\"ydom\\\"\\n      },\\n      \\\"range\\\": {\\n        \\\"signal\\\": \\\"yrange\\\"\\n      }\\n    },\\n    {\\n    ##  Makes nodeSize relative to the nodes on the current screen \\n      \\\"name\\\": \\\"nodeSize\\\",\\n      \\\"type\\\": \\\"linear\\\",\\n      \\\"domain\\\": {\\\"data\\\": \\\"node-data-raw\\\", \\\"field\\\": \\\"doc_count\\\"},\\n      \\\"range\\\": [500,700],\\n    },\\n    {\\n    ##  Used for Address Type Legend \\n      \\\"name\\\": \\\"shape\\\",\\n      \\\"type\\\": \\\"ordinal\\\",\\n      \\\"domain\\\": [\\\"non-broadcast\\\", \\\"broadcast\\\"],\\n      \\\"range\\\": [\\\"circle\\\", \\\"cross\\\"], \\n    },\\n    \\n  ],\\n## ----------------------------------------------------------------------------------------------------------------------------\\n##  SECTION 4: Legends --------------------------------------------------------------------------------------------------------\\n##  Visual representation of scales for user to interprete data \\n  \\\"legends\\\": [\\n    {\\n    ##  Legend for role colors \\n      \\\"title\\\": \\\"Roles\\\",\\n      \\\"fill\\\": \\\"color\\\",\\n      \\\"fillColor\\\": \\\"beige\\\",\\n      \\\"padding\\\": 10,\\n      \\\"symbolType\\\": \\\"diamond\\\",\\n      \\\"symbolOpacity\\\": 0.8,\\n      \\\"symbolStrokeColor\\\": \\\"#3f444d\\\",\\n      \\\"symbolStrokeWidth\\\": 1.5,\\n      \\\"symbolSize\\\": 300,\\n      \\\"labelColor\\\": \\\"#3f444d\\\",\\n      \\\"labelFont\\\": \\\"Segoe UI\\\",\\n      \\\"labelFontSize\\\": 16,\\n      \\\"titleColor\\\": \\\"#3f444d\\\",\\n      \\\"titleFont\\\": \\\"Segoe UI\\\",\\n      \\\"titleAnchor\\\": \\\"center\\\",\\n      \\\"titleFontSize\\\": 18,\\n      \\\"titlePadding\\\": 6,\\n      \\\"columns\\\": 2,\\n      \\\"cornerRadius\\\": 5,\\n      ##  Referenced in Config section\\n      \\\"orient\\\":\\\"top-right\\\",\\n    },\\n    {\\n    ##  Legend for node shape\\n      \\\"title\\\": \\\"Address Type\\\",\\n      \\\"shape\\\": \\\"shape\\\",\\n      \\\"fillColor\\\": \\\"beige\\\",\\n      \\\"gradientOpacity\\\": 7,\\n      \\\"padding\\\": 10,\\n      \\\"symbolSize\\\": 300,\\n      \\\"symbolOpacity\\\": 0.7,\\n      \\\"symbolStrokeColor\\\": \\\"#3f444d\\\",\\n      \\\"symbolStrokeWidth\\\": 2,\\n      \\\"labelColor\\\": \\\"#3f444d\\\",\\n      \\\"labelFont\\\": \\\"Segoe UI\\\",\\n      \\\"labelFontSize\\\": 16,\\n      \\\"titleColor\\\": \\\"#3f444d\\\",\\n      \\\"titleFont\\\": \\\"Segoe UI\\\",\\n      \\\"titleFontSize\\\": 18,\\n      \\\"titleAnchor\\\": \\\"center\\\",\\n      \\\"titlePadding\\\": 6,\\n      \\\"columns\\\": 2,\\n      \\\"cornerRadius\\\": 5,\\n      ##  Referenced in Config section\\n      \\\"orient\\\":\\\"top-right\\\",\\n      \\n      \\n    },\\n  ],\\n## --------------------------------------------------------------------------------------------------------------------------\\n##  SECTION 5: Marks --------------------------------------------------------------------------------------------------------\\n##  Determines how the data visually appears in the visualization\\n  \\\"marks\\\": [\\n    {\\n    ##  Connections between visual nodes\\n      \\\"type\\\": \\\"path\\\",\\n      \\\"name\\\": \\\"links\\\",\\n      \\\"zindex\\\": 1,\\n      \\\"from\\\": {\\\"data\\\": \\\"link-data2\\\"},\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"path\\\": {\\\"field\\\": \\\"path\\\"},\\n          ##  Logic set to shade links to grey when wither of the nodes are hovered over \\n          \\\"stroke\\\": { \\\"signal\\\": \\\"(datum.source.index!=nodeHover.id && datum.target.index!=nodeHover.id) ? '#4FB9AF' :merge(hsl(scale('color', datum.source.group)), {l:0.64})\\\"},\\n          ##  Logic set to change link width to grey when wither of the nodes are hovered over \\n          \\\"strokeWidth\\\": { \\\"signal\\\": \\\"datum.source.index!=nodeHover.id && datum.target.index!=nodeHover.id ? 3:5\\\"},\\n        },\\n        \\\"hover\\\": {\\n        ##  Defines hover behvaior of links \\n          \\\"cursor\\\": {\\\"value\\\":\\\"pointer\\\"},\\n          \\\"tooltip\\\": {\\\"signal\\\": \\\"datum.bidirectional == true ? {'direction': 'bi-directional', 'connection': datum.key.src+' ↔ ' +datum.key.dst} : {'direction':'uni-directional', 'connection': datum.key.src+' → ' +datum.key.dst}\\\"}\\n        }\\n       },\\n       \\\"transform\\\": [\\n        ##  OPTIMIZE: Unsure why linkpath transform is duplicated in specification? \\n        {\\n          \\\"type\\\": \\\"linkpath\\\",\\n          \\\"require\\\": {\\\"signal\\\": \\\"force\\\"},\\n          \\\"shape\\\": \\\"line\\\",\\n          \\\"sourceX\\\": {\\\"expr\\\": \\\"scale('xscale', datum.datum.source.x)\\\"},\\n          \\\"sourceY\\\": {\\\"expr\\\": \\\"scale('yscale', datum.datum.source.y)\\\"},\\n          \\\"targetX\\\": {\\\"expr\\\": \\\"scale('xscale', datum.datum.target.x)\\\"},\\n          \\\"targetY\\\": {\\\"expr\\\": \\\"scale('yscale', datum.datum.target.y)\\\"}\\n        },\\n        ##  Calculate angle values for positioning angles - imported from Deneb Force Directed graph so unsure how it works but it does\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"atan2(datum.datum.target.y - datum.datum.source.y,datum.datum.source.x - datum.datum.target.x)\\\",\\n          \\\"as\\\": \\\"angle1\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(datum.angle1>=0?datum.angle1:(2*PI + datum.angle1)) * (360 / (2*PI))\\\",\\n          \\\"as\\\": \\\"angle2\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(360-datum.angle2)*(PI/180)\\\",\\n          \\\"as\\\": \\\"angle3\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(cos(datum.angle3)*(nodeRadius+5))+(scale('xscale',datum.datum.target.x))\\\",\\n          \\\"as\\\": \\\"arrowX\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(sin(datum.angle3)*(nodeRadius+5))+(scale('yscale',datum.datum.target.y))\\\",\\n          \\\"as\\\": \\\"arrowY\\\"\\n        }\\n      ]\\n    },\\n    {\\n    ##  Arrows representing connections between nodes\\n      \\\"type\\\": \\\"symbol\\\",\\n      \\\"name\\\": \\\"arrows\\\",\\n      \\\"zindex\\\": 1,\\n      ##  NOTE: The data is another 'mark' source, not a 'data' source \\n      \\\"from\\\": { \\\"data\\\": \\\"links\\\"},\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"shape\\\": {\\\"value\\\": \\\"triangle\\\"},\\n          \\\"angle\\\": {\\\"signal\\\": \\\"-datum.angle2-90\\\"},\\n          \\\"x\\\": {\\\"signal\\\": \\\"datum.arrowX\\\" },\\n          \\\"y\\\": {\\\"signal\\\": \\\"datum.arrowY\\\"},\\n          \\\"text\\\": {\\\"signal\\\": \\\"'▲'\\\"},\\n          /*\\n          ##  DEBUG: When fill is not commented out it breaks the arrow behavior - no idea why\\n          \\\"fill\\\": {\\\"signal\\\": \\\"datum.source.index!=nodeHover.id && datum.target.index!=nodeHover.id ? '#929399':merge(hsl(scale('color', datum.source.group)), {l:0.64})\\\"},\\n          */\\n          \\\"size\\\": { \\\"signal\\\": \\\"nodeRadius==1 ? 0 : 300\\\"},\\n        },\\n      }\\n    },\\n    {\\n    ##  Visual representation of the nodes \\n      \\\"type\\\": \\\"symbol\\\",\\n      \\\"name\\\": \\\"nodes\\\",\\n      \\\"zindex\\\": 1,\\n      \\\"from\\\": {\\\"data\\\": \\\"node-data\\\"},\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"opacity\\\": {\\\"value\\\": 1},\\n          ##  Determine if ip address is broadcast or not and change shape accordingly \\n          \\\"shape\\\": {\\\"signal\\\": \\\" split(datum.ip,'.')[3] === '255' ? 'cross' : 'circle'\\\"},\\n          \\\"fill\\\": {\\\"signal\\\": \\\"nodeHover.id===datum.index || indexof(nodeHover.connections, datum.ip)>-1 ?'grey' :merge(hsl(scale('color', datum.roles)), {l:0.64})\\\"},\\n          \\\"stroke\\\": {\\\"signal\\\": \\\"nodeHover.id===datum.index || indexof(nodeHover.connections, datum.ip)>-1 ? scale('color', datum.device):merge(hsl(scale('color', datum.device)), {l:0.84})\\\" },\\n          \\\"strokeWidth\\\": { \\\"value\\\": 3},\\n          \\\"strokeOpacity\\\": {\\\"value\\\": 1 },\\n          \\\"size\\\": {\\\"signal\\\":\\\"dynamicRadius ? datum.size_node : 4 * nodeRadius * nodeRadius\\\"},\\n          \\\"cursor\\\": {\\\"value\\\": \\\"pointer\\\"},\\n          \\\"x\\\": {\\\"signal\\\": \\\"fix[0]!=null && node===datum.index ?fix[0]:scale('xscale', datum.x)\\\" },\\n          \\\"y\\\": {\\\"signal\\\": \\\"fix[1]!=null && node===datum.index ?fix[1]:scale('yscale', datum.y)\\\"}\\n        },\\n        \\\"hover\\\": {\\n          \\\"tooltip\\\": { \\\"signal\\\": \\\"{'IP': datum.ip, 'Tag': datum.group, 'Connections': datum.doc_count, 'Device Role': datum.roles || 'unknown', 'Device Manufacturer': datum.manufacturer || 'unknown', 'Device Name': datum.name || 'unknown'}\\\"}\\n        },\\n      },\\n    },\\n    {\\n      \\\"type\\\": \\\"text\\\",\\n      \\\"name\\\": \\\"node-label\\\",\\n      \\\"zindex\\\": 2,\\n      \\\"from\\\": {\\\"data\\\": \\\"node-data\\\"},\\n      \\\"encode\\\": {\\n        \\\"update\\\": {\\n          \\\"text\\\": {\\\"signal\\\": \\\"datum.ip\\\"},\\n          \\\"fontWeight\\\": {\\\"value\\\": \\\"bold\\\"},\\n          \\\"fill\\\":{\\\"value\\\":\\\"#FFE4B5\\\"},\\n          \\\"cursor\\\": {\\\"value\\\": \\\"pointer\\\"},\\n          \\\"dx\\\": {\\\"value\\\": -2},\\n          \\\"dy\\\": {\\\"value\\\": -16},\\n          \\\"x\\\": {\\\"signal\\\": \\\"fix[0]!=null && node===datum.index ?fix[0]:scale('xscale', datum.x)\\\" },\\n          \\\"y\\\": {\\\"signal\\\": \\\"fix[1]!=null && node===datum.index ?fix[1]:scale('yscale', datum.y)\\\"}\\n        },\\n      }\\n    }\\n ] \\n## --------------------------------------------------------------------------------------------------------------------------\\n##  End of Spec :) \\n}\"}}"
      },
      "id": "638d9e80-be63-11ef-9ff5-ff2a2927176e",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-10-20T19:34:41.472Z",
      "version": "WzE2MTUsMV0="
    },
    {
      "attributes": {
        "columns": [
          "_source"
        ],
        "description": "",
        "hits": 0,
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"highlightAll\":false,\"version\":true,\"query\":{\"query\":\"tags:netbox\",\"language\":\"kuery\"},\"filter\":[],\"indexRefName\":\"kibanaSavedObjectMeta.searchSourceJSON.index\"}"
        },
        "sort": [],
        "title": "NetBox Enrichment - Logs",
        "version": 1
      },
      "id": "b1645e70-8182-11ed-8ccb-af218b39580f",
      "migrationVersion": {
        "search": "7.9.3"
      },
      "namespaces": [
        "default"
      ],
      "references": [
        {
          "id": "MALCOLM_NETWORK_INDEX_PATTERN_REPLACER",
          "name": "kibanaSavedObjectMeta.searchSourceJSON.index",
          "type": "index-pattern"
        }
      ],
      "type": "search",
      "updated_at": "2025-10-20T19:16:08.928Z",
      "version": "WzE1MjksMV0="
    }
  ],
  "version": "3.2.0"
}
